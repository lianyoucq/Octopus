#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Jan 20 15:25:25 2018 by generateDS.py version 2.29.5.
# Python 3.6.3 (default, Oct  6 2017, 08:44:35)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('-f', '')
#   ('-a', 'xsd:')
#   ('--super', 'domainservice')
#   ('-o', 'domainservice.py')
#   ('-s', 'subdomainservice.py')
#
# Command line arguments:
#   /opt/infa/pwc/1020/shared/bin/com.informatica.isp.metadata.domainservice.xsd
#
# Command line:
#   /home/arthur/.virtualenvs/octopus-tentacle/bin/generateDS.py -f -a "xsd:" --super="domainservice" -o "domainservice.py" -s "subdomainservice.py" /opt/infa/pwc/1020/shared/bin/com.informatica.isp.metadata.domainservice.xsd
#
# Current working directory (os.getcwd()):
#   octopus-tentacle
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DBConnectivity(GeneratedsSuper):
    """Model Change Log 2.11.0 sumittal 10/09/2013 Added the attributes
    isDBSSLEnabled and truststorePassword Changed the property size
    of dbConnectionString from LengthTypeMax.GENERAL_URI to
    LengthTypeMax.UNBOUNDED 2.13.0 creddy 3/21/2013 Added a new
    property 'dbTruststoreLocation'"""
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, dbConnectString=None, dbEncryptedPassword=None, dbHost=None, dbName=None, dbPort=None, dbSchema=None, dbTLSEnabled=None, dbTableSpace=None, dbTruststoreLocation=None, dbType=None, dbUsername=None, trustedConnection=None, truststorePassword=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.dbConnectString = _cast(None, dbConnectString)
        self.dbEncryptedPassword = _cast(None, dbEncryptedPassword)
        self.dbHost = _cast(None, dbHost)
        self.dbName = _cast(None, dbName)
        self.dbPort = _cast(int, dbPort)
        self.dbSchema = _cast(None, dbSchema)
        self.dbTLSEnabled = _cast(bool, dbTLSEnabled)
        self.dbTableSpace = _cast(None, dbTableSpace)
        self.dbTruststoreLocation = _cast(None, dbTruststoreLocation)
        self.dbType = _cast(None, dbType)
        self.dbUsername = _cast(None, dbUsername)
        self.trustedConnection = _cast(bool, trustedConnection)
        self.truststorePassword = _cast(None, truststorePassword)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DBConnectivity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DBConnectivity.subclass:
            return DBConnectivity.subclass(*args_, **kwargs_)
        else:
            return DBConnectivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_dbConnectString(self): return self.dbConnectString
    def set_dbConnectString(self, dbConnectString): self.dbConnectString = dbConnectString
    def get_dbEncryptedPassword(self): return self.dbEncryptedPassword
    def set_dbEncryptedPassword(self, dbEncryptedPassword): self.dbEncryptedPassword = dbEncryptedPassword
    def get_dbHost(self): return self.dbHost
    def set_dbHost(self, dbHost): self.dbHost = dbHost
    def get_dbName(self): return self.dbName
    def set_dbName(self, dbName): self.dbName = dbName
    def get_dbPort(self): return self.dbPort
    def set_dbPort(self, dbPort): self.dbPort = dbPort
    def get_dbSchema(self): return self.dbSchema
    def set_dbSchema(self, dbSchema): self.dbSchema = dbSchema
    def get_dbTLSEnabled(self): return self.dbTLSEnabled
    def set_dbTLSEnabled(self, dbTLSEnabled): self.dbTLSEnabled = dbTLSEnabled
    def get_dbTableSpace(self): return self.dbTableSpace
    def set_dbTableSpace(self, dbTableSpace): self.dbTableSpace = dbTableSpace
    def get_dbTruststoreLocation(self): return self.dbTruststoreLocation
    def set_dbTruststoreLocation(self, dbTruststoreLocation): self.dbTruststoreLocation = dbTruststoreLocation
    def get_dbType(self): return self.dbType
    def set_dbType(self, dbType): self.dbType = dbType
    def get_dbUsername(self): return self.dbUsername
    def set_dbUsername(self, dbUsername): self.dbUsername = dbUsername
    def get_trustedConnection(self): return self.trustedConnection
    def set_trustedConnection(self, trustedConnection): self.trustedConnection = trustedConnection
    def get_truststorePassword(self): return self.truststorePassword
    def set_truststorePassword(self, truststorePassword): self.truststorePassword = truststorePassword
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='DBConnectivity', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DBConnectivity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DBConnectivity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='DBConnectivity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='DBConnectivity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.dbConnectString is not None and 'dbConnectString' not in already_processed:
            already_processed.add('dbConnectString')
            outfile.write(' dbConnectString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbConnectString), input_name='dbConnectString')), ))
        if self.dbEncryptedPassword is not None and 'dbEncryptedPassword' not in already_processed:
            already_processed.add('dbEncryptedPassword')
            outfile.write(' dbEncryptedPassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbEncryptedPassword), input_name='dbEncryptedPassword')), ))
        if self.dbHost is not None and 'dbHost' not in already_processed:
            already_processed.add('dbHost')
            outfile.write(' dbHost=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbHost), input_name='dbHost')), ))
        if self.dbName is not None and 'dbName' not in already_processed:
            already_processed.add('dbName')
            outfile.write(' dbName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbName), input_name='dbName')), ))
        if self.dbPort is not None and 'dbPort' not in already_processed:
            already_processed.add('dbPort')
            outfile.write(' dbPort="%s"' % self.gds_format_integer(self.dbPort, input_name='dbPort'))
        if self.dbSchema is not None and 'dbSchema' not in already_processed:
            already_processed.add('dbSchema')
            outfile.write(' dbSchema=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbSchema), input_name='dbSchema')), ))
        if self.dbTLSEnabled is not None and 'dbTLSEnabled' not in already_processed:
            already_processed.add('dbTLSEnabled')
            outfile.write(' dbTLSEnabled="%s"' % self.gds_format_boolean(self.dbTLSEnabled, input_name='dbTLSEnabled'))
        if self.dbTableSpace is not None and 'dbTableSpace' not in already_processed:
            already_processed.add('dbTableSpace')
            outfile.write(' dbTableSpace=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbTableSpace), input_name='dbTableSpace')), ))
        if self.dbTruststoreLocation is not None and 'dbTruststoreLocation' not in already_processed:
            already_processed.add('dbTruststoreLocation')
            outfile.write(' dbTruststoreLocation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbTruststoreLocation), input_name='dbTruststoreLocation')), ))
        if self.dbType is not None and 'dbType' not in already_processed:
            already_processed.add('dbType')
            outfile.write(' dbType=%s' % (quote_attrib(self.dbType), ))
        if self.dbUsername is not None and 'dbUsername' not in already_processed:
            already_processed.add('dbUsername')
            outfile.write(' dbUsername=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dbUsername), input_name='dbUsername')), ))
        if self.trustedConnection is not None and 'trustedConnection' not in already_processed:
            already_processed.add('trustedConnection')
            outfile.write(' trustedConnection="%s"' % self.gds_format_boolean(self.trustedConnection, input_name='trustedConnection'))
        if self.truststorePassword is not None and 'truststorePassword' not in already_processed:
            already_processed.add('truststorePassword')
            outfile.write(' truststorePassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.truststorePassword), input_name='truststorePassword')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='DBConnectivity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('dbConnectString', node)
        if value is not None and 'dbConnectString' not in already_processed:
            already_processed.add('dbConnectString')
            self.dbConnectString = value
        value = find_attr_value_('dbEncryptedPassword', node)
        if value is not None and 'dbEncryptedPassword' not in already_processed:
            already_processed.add('dbEncryptedPassword')
            self.dbEncryptedPassword = value
        value = find_attr_value_('dbHost', node)
        if value is not None and 'dbHost' not in already_processed:
            already_processed.add('dbHost')
            self.dbHost = value
        value = find_attr_value_('dbName', node)
        if value is not None and 'dbName' not in already_processed:
            already_processed.add('dbName')
            self.dbName = value
        value = find_attr_value_('dbPort', node)
        if value is not None and 'dbPort' not in already_processed:
            already_processed.add('dbPort')
            try:
                self.dbPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dbSchema', node)
        if value is not None and 'dbSchema' not in already_processed:
            already_processed.add('dbSchema')
            self.dbSchema = value
        value = find_attr_value_('dbTLSEnabled', node)
        if value is not None and 'dbTLSEnabled' not in already_processed:
            already_processed.add('dbTLSEnabled')
            if value in ('true', '1'):
                self.dbTLSEnabled = True
            elif value in ('false', '0'):
                self.dbTLSEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dbTableSpace', node)
        if value is not None and 'dbTableSpace' not in already_processed:
            already_processed.add('dbTableSpace')
            self.dbTableSpace = value
        value = find_attr_value_('dbTruststoreLocation', node)
        if value is not None and 'dbTruststoreLocation' not in already_processed:
            already_processed.add('dbTruststoreLocation')
            self.dbTruststoreLocation = value
        value = find_attr_value_('dbType', node)
        if value is not None and 'dbType' not in already_processed:
            already_processed.add('dbType')
            self.dbType = value
        value = find_attr_value_('dbUsername', node)
        if value is not None and 'dbUsername' not in already_processed:
            already_processed.add('dbUsername')
            self.dbUsername = value
        value = find_attr_value_('trustedConnection', node)
        if value is not None and 'trustedConnection' not in already_processed:
            already_processed.add('trustedConnection')
            if value in ('true', '1'):
                self.trustedConnection = True
            elif value in ('false', '0'):
                self.trustedConnection = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('truststorePassword', node)
        if value is not None and 'truststorePassword' not in already_processed:
            already_processed.add('truststorePassword')
            self.truststorePassword = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class DBConnectivity


class EarlierInfaHomeConfig(GeneratedsSuper):
    """Model Change Log 2.17.0 vmehta 1/06/2017 Added EalierInfaHomeConfig
    model"""
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, earlierInfaHome=None, earlierInfaHomeVersion=None, earlierJavaHome=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.earlierInfaHome = _cast(None, earlierInfaHome)
        self.earlierInfaHomeVersion = _cast(None, earlierInfaHomeVersion)
        self.earlierJavaHome = _cast(None, earlierJavaHome)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EarlierInfaHomeConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EarlierInfaHomeConfig.subclass:
            return EarlierInfaHomeConfig.subclass(*args_, **kwargs_)
        else:
            return EarlierInfaHomeConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_earlierInfaHome(self): return self.earlierInfaHome
    def set_earlierInfaHome(self, earlierInfaHome): self.earlierInfaHome = earlierInfaHome
    def get_earlierInfaHomeVersion(self): return self.earlierInfaHomeVersion
    def set_earlierInfaHomeVersion(self, earlierInfaHomeVersion): self.earlierInfaHomeVersion = earlierInfaHomeVersion
    def get_earlierJavaHome(self): return self.earlierJavaHome
    def set_earlierJavaHome(self, earlierJavaHome): self.earlierJavaHome = earlierJavaHome
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='EarlierInfaHomeConfig', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EarlierInfaHomeConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EarlierInfaHomeConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='EarlierInfaHomeConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='EarlierInfaHomeConfig'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.earlierInfaHome is not None and 'earlierInfaHome' not in already_processed:
            already_processed.add('earlierInfaHome')
            outfile.write(' earlierInfaHome=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.earlierInfaHome), input_name='earlierInfaHome')), ))
        if self.earlierInfaHomeVersion is not None and 'earlierInfaHomeVersion' not in already_processed:
            already_processed.add('earlierInfaHomeVersion')
            outfile.write(' earlierInfaHomeVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.earlierInfaHomeVersion), input_name='earlierInfaHomeVersion')), ))
        if self.earlierJavaHome is not None and 'earlierJavaHome' not in already_processed:
            already_processed.add('earlierJavaHome')
            outfile.write(' earlierJavaHome=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.earlierJavaHome), input_name='earlierJavaHome')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='EarlierInfaHomeConfig', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('earlierInfaHome', node)
        if value is not None and 'earlierInfaHome' not in already_processed:
            already_processed.add('earlierInfaHome')
            self.earlierInfaHome = value
        value = find_attr_value_('earlierInfaHomeVersion', node)
        if value is not None and 'earlierInfaHomeVersion' not in already_processed:
            already_processed.add('earlierInfaHomeVersion')
            self.earlierInfaHomeVersion = value
        value = find_attr_value_('earlierJavaHome', node)
        if value is not None and 'earlierJavaHome' not in already_processed:
            already_processed.add('earlierJavaHome')
            self.earlierJavaHome = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class EarlierInfaHomeConfig


class HttpsInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, encryptedKeystorePass=None, httpsPort=None, keystoreFile=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.encryptedKeystorePass = _cast(None, encryptedKeystorePass)
        self.httpsPort = _cast(int, httpsPort)
        self.keystoreFile = _cast(None, keystoreFile)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HttpsInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HttpsInfo.subclass:
            return HttpsInfo.subclass(*args_, **kwargs_)
        else:
            return HttpsInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_encryptedKeystorePass(self): return self.encryptedKeystorePass
    def set_encryptedKeystorePass(self, encryptedKeystorePass): self.encryptedKeystorePass = encryptedKeystorePass
    def get_httpsPort(self): return self.httpsPort
    def set_httpsPort(self, httpsPort): self.httpsPort = httpsPort
    def get_keystoreFile(self): return self.keystoreFile
    def set_keystoreFile(self, keystoreFile): self.keystoreFile = keystoreFile
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='HttpsInfo', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HttpsInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HttpsInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='HttpsInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='HttpsInfo'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.encryptedKeystorePass is not None and 'encryptedKeystorePass' not in already_processed:
            already_processed.add('encryptedKeystorePass')
            outfile.write(' encryptedKeystorePass=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.encryptedKeystorePass), input_name='encryptedKeystorePass')), ))
        if self.httpsPort is not None and 'httpsPort' not in already_processed:
            already_processed.add('httpsPort')
            outfile.write(' httpsPort="%s"' % self.gds_format_integer(self.httpsPort, input_name='httpsPort'))
        if self.keystoreFile is not None and 'keystoreFile' not in already_processed:
            already_processed.add('keystoreFile')
            outfile.write(' keystoreFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keystoreFile), input_name='keystoreFile')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='HttpsInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('encryptedKeystorePass', node)
        if value is not None and 'encryptedKeystorePass' not in already_processed:
            already_processed.add('encryptedKeystorePass')
            self.encryptedKeystorePass = value
        value = find_attr_value_('httpsPort', node)
        if value is not None and 'httpsPort' not in already_processed:
            already_processed.add('httpsPort')
            try:
                self.httpsPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('keystoreFile', node)
        if value is not None and 'keystoreFile' not in already_processed:
            already_processed.add('keystoreFile')
            self.keystoreFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class HttpsInfo


class NodeSamlConfig(GeneratedsSuper):
    """Model Change Log 2.18.0 vmehta 2/1/2017 Added NodeSamlConfig model"""
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, assertionSigningCertificateAlias=None, samlEnabled=None, samlTrustStore=None, samlTrustStorePassword=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.assertionSigningCertificateAlias = _cast(None, assertionSigningCertificateAlias)
        self.samlEnabled = _cast(bool, samlEnabled)
        self.samlTrustStore = _cast(None, samlTrustStore)
        self.samlTrustStorePassword = _cast(None, samlTrustStorePassword)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NodeSamlConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NodeSamlConfig.subclass:
            return NodeSamlConfig.subclass(*args_, **kwargs_)
        else:
            return NodeSamlConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_assertionSigningCertificateAlias(self): return self.assertionSigningCertificateAlias
    def set_assertionSigningCertificateAlias(self, assertionSigningCertificateAlias): self.assertionSigningCertificateAlias = assertionSigningCertificateAlias
    def get_samlEnabled(self): return self.samlEnabled
    def set_samlEnabled(self, samlEnabled): self.samlEnabled = samlEnabled
    def get_samlTrustStore(self): return self.samlTrustStore
    def set_samlTrustStore(self, samlTrustStore): self.samlTrustStore = samlTrustStore
    def get_samlTrustStorePassword(self): return self.samlTrustStorePassword
    def set_samlTrustStorePassword(self, samlTrustStorePassword): self.samlTrustStorePassword = samlTrustStorePassword
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='NodeSamlConfig', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NodeSamlConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeSamlConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='NodeSamlConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='NodeSamlConfig'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.assertionSigningCertificateAlias is not None and 'assertionSigningCertificateAlias' not in already_processed:
            already_processed.add('assertionSigningCertificateAlias')
            outfile.write(' assertionSigningCertificateAlias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.assertionSigningCertificateAlias), input_name='assertionSigningCertificateAlias')), ))
        if self.samlEnabled is not None and 'samlEnabled' not in already_processed:
            already_processed.add('samlEnabled')
            outfile.write(' samlEnabled="%s"' % self.gds_format_boolean(self.samlEnabled, input_name='samlEnabled'))
        if self.samlTrustStore is not None and 'samlTrustStore' not in already_processed:
            already_processed.add('samlTrustStore')
            outfile.write(' samlTrustStore=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.samlTrustStore), input_name='samlTrustStore')), ))
        if self.samlTrustStorePassword is not None and 'samlTrustStorePassword' not in already_processed:
            already_processed.add('samlTrustStorePassword')
            outfile.write(' samlTrustStorePassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.samlTrustStorePassword), input_name='samlTrustStorePassword')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='NodeSamlConfig', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('assertionSigningCertificateAlias', node)
        if value is not None and 'assertionSigningCertificateAlias' not in already_processed:
            already_processed.add('assertionSigningCertificateAlias')
            self.assertionSigningCertificateAlias = value
        value = find_attr_value_('samlEnabled', node)
        if value is not None and 'samlEnabled' not in already_processed:
            already_processed.add('samlEnabled')
            if value in ('true', '1'):
                self.samlEnabled = True
            elif value in ('false', '0'):
                self.samlEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('samlTrustStore', node)
        if value is not None and 'samlTrustStore' not in already_processed:
            already_processed.add('samlTrustStore')
            self.samlTrustStore = value
        value = find_attr_value_('samlTrustStorePassword', node)
        if value is not None and 'samlTrustStorePassword' not in already_processed:
            already_processed.add('samlTrustStorePassword')
            self.samlTrustStorePassword = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class NodeSamlConfig


class SecurityConfig(GeneratedsSuper):
    """Model Change Log 2.8.0 nupaman 13/06/2013 Added SecurityConfig model
    2.10.0 sumittal 06/09/2013 Updated the keytabDirectory property
    name to secretKeysDirectory Added the property isSensitive true
    for the fields keystorePassword and trustStorePassword 2.12.0
    skakkar 14/10/2013 Added a new property "siteKeyHashValue" .
    This property will store the hash value of site specific key.
    2.18.0 vmehta 2/1/2013 Added NodeSamlConfig model to
    SecurityConfig"""
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, ciphers=None, kerberosEnabled=None, keystore=None, keystorePassword=None, nodeUserAccount=None, secretKeysDirectory=None, serviceRealmName=None, siteKeyHashValue=None, trustStore=None, trustStorePassword=None, userRealmName=None, annotations=None, nodeSamlConfig=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.ciphers = _cast(None, ciphers)
        self.kerberosEnabled = _cast(bool, kerberosEnabled)
        self.keystore = _cast(None, keystore)
        self.keystorePassword = _cast(None, keystorePassword)
        self.nodeUserAccount = _cast(None, nodeUserAccount)
        self.secretKeysDirectory = _cast(None, secretKeysDirectory)
        self.serviceRealmName = _cast(None, serviceRealmName)
        self.siteKeyHashValue = _cast(None, siteKeyHashValue)
        self.trustStore = _cast(None, trustStore)
        self.trustStorePassword = _cast(None, trustStorePassword)
        self.userRealmName = _cast(None, userRealmName)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
        if nodeSamlConfig is None:
            self.nodeSamlConfig = []
        else:
            self.nodeSamlConfig = nodeSamlConfig
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SecurityConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SecurityConfig.subclass:
            return SecurityConfig.subclass(*args_, **kwargs_)
        else:
            return SecurityConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_nodeSamlConfig(self): return self.nodeSamlConfig
    def set_nodeSamlConfig(self, nodeSamlConfig): self.nodeSamlConfig = nodeSamlConfig
    def add_nodeSamlConfig(self, value): self.nodeSamlConfig.append(value)
    def insert_nodeSamlConfig_at(self, index, value): self.nodeSamlConfig.insert(index, value)
    def replace_nodeSamlConfig_at(self, index, value): self.nodeSamlConfig[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_ciphers(self): return self.ciphers
    def set_ciphers(self, ciphers): self.ciphers = ciphers
    def get_kerberosEnabled(self): return self.kerberosEnabled
    def set_kerberosEnabled(self, kerberosEnabled): self.kerberosEnabled = kerberosEnabled
    def get_keystore(self): return self.keystore
    def set_keystore(self, keystore): self.keystore = keystore
    def get_keystorePassword(self): return self.keystorePassword
    def set_keystorePassword(self, keystorePassword): self.keystorePassword = keystorePassword
    def get_nodeUserAccount(self): return self.nodeUserAccount
    def set_nodeUserAccount(self, nodeUserAccount): self.nodeUserAccount = nodeUserAccount
    def get_secretKeysDirectory(self): return self.secretKeysDirectory
    def set_secretKeysDirectory(self, secretKeysDirectory): self.secretKeysDirectory = secretKeysDirectory
    def get_serviceRealmName(self): return self.serviceRealmName
    def set_serviceRealmName(self, serviceRealmName): self.serviceRealmName = serviceRealmName
    def get_siteKeyHashValue(self): return self.siteKeyHashValue
    def set_siteKeyHashValue(self, siteKeyHashValue): self.siteKeyHashValue = siteKeyHashValue
    def get_trustStore(self): return self.trustStore
    def set_trustStore(self, trustStore): self.trustStore = trustStore
    def get_trustStorePassword(self): return self.trustStorePassword
    def set_trustStorePassword(self, trustStorePassword): self.trustStorePassword = trustStorePassword
    def get_userRealmName(self): return self.userRealmName
    def set_userRealmName(self, userRealmName): self.userRealmName = userRealmName
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations or
            self.nodeSamlConfig
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='SecurityConfig', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SecurityConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecurityConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='SecurityConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='SecurityConfig'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.ciphers is not None and 'ciphers' not in already_processed:
            already_processed.add('ciphers')
            outfile.write(' ciphers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ciphers), input_name='ciphers')), ))
        if self.kerberosEnabled is not None and 'kerberosEnabled' not in already_processed:
            already_processed.add('kerberosEnabled')
            outfile.write(' kerberosEnabled="%s"' % self.gds_format_boolean(self.kerberosEnabled, input_name='kerberosEnabled'))
        if self.keystore is not None and 'keystore' not in already_processed:
            already_processed.add('keystore')
            outfile.write(' keystore=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keystore), input_name='keystore')), ))
        if self.keystorePassword is not None and 'keystorePassword' not in already_processed:
            already_processed.add('keystorePassword')
            outfile.write(' keystorePassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keystorePassword), input_name='keystorePassword')), ))
        if self.nodeUserAccount is not None and 'nodeUserAccount' not in already_processed:
            already_processed.add('nodeUserAccount')
            outfile.write(' nodeUserAccount=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nodeUserAccount), input_name='nodeUserAccount')), ))
        if self.secretKeysDirectory is not None and 'secretKeysDirectory' not in already_processed:
            already_processed.add('secretKeysDirectory')
            outfile.write(' secretKeysDirectory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secretKeysDirectory), input_name='secretKeysDirectory')), ))
        if self.serviceRealmName is not None and 'serviceRealmName' not in already_processed:
            already_processed.add('serviceRealmName')
            outfile.write(' serviceRealmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceRealmName), input_name='serviceRealmName')), ))
        if self.siteKeyHashValue is not None and 'siteKeyHashValue' not in already_processed:
            already_processed.add('siteKeyHashValue')
            outfile.write(' siteKeyHashValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.siteKeyHashValue), input_name='siteKeyHashValue')), ))
        if self.trustStore is not None and 'trustStore' not in already_processed:
            already_processed.add('trustStore')
            outfile.write(' trustStore=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trustStore), input_name='trustStore')), ))
        if self.trustStorePassword is not None and 'trustStorePassword' not in already_processed:
            already_processed.add('trustStorePassword')
            outfile.write(' trustStorePassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trustStorePassword), input_name='trustStorePassword')), ))
        if self.userRealmName is not None and 'userRealmName' not in already_processed:
            already_processed.add('userRealmName')
            outfile.write(' userRealmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.userRealmName), input_name='userRealmName')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='SecurityConfig', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
        for nodeSamlConfig_ in self.nodeSamlConfig:
            nodeSamlConfig_.export(outfile, level, namespace_, name_='nodeSamlConfig', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('ciphers', node)
        if value is not None and 'ciphers' not in already_processed:
            already_processed.add('ciphers')
            self.ciphers = value
        value = find_attr_value_('kerberosEnabled', node)
        if value is not None and 'kerberosEnabled' not in already_processed:
            already_processed.add('kerberosEnabled')
            if value in ('true', '1'):
                self.kerberosEnabled = True
            elif value in ('false', '0'):
                self.kerberosEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('keystore', node)
        if value is not None and 'keystore' not in already_processed:
            already_processed.add('keystore')
            self.keystore = value
        value = find_attr_value_('keystorePassword', node)
        if value is not None and 'keystorePassword' not in already_processed:
            already_processed.add('keystorePassword')
            self.keystorePassword = value
        value = find_attr_value_('nodeUserAccount', node)
        if value is not None and 'nodeUserAccount' not in already_processed:
            already_processed.add('nodeUserAccount')
            self.nodeUserAccount = value
        value = find_attr_value_('secretKeysDirectory', node)
        if value is not None and 'secretKeysDirectory' not in already_processed:
            already_processed.add('secretKeysDirectory')
            self.secretKeysDirectory = value
        value = find_attr_value_('serviceRealmName', node)
        if value is not None and 'serviceRealmName' not in already_processed:
            already_processed.add('serviceRealmName')
            self.serviceRealmName = value
        value = find_attr_value_('siteKeyHashValue', node)
        if value is not None and 'siteKeyHashValue' not in already_processed:
            already_processed.add('siteKeyHashValue')
            self.siteKeyHashValue = value
        value = find_attr_value_('trustStore', node)
        if value is not None and 'trustStore' not in already_processed:
            already_processed.add('trustStore')
            self.trustStore = value
        value = find_attr_value_('trustStorePassword', node)
        if value is not None and 'trustStorePassword' not in already_processed:
            already_processed.add('trustStorePassword')
            self.trustStorePassword = value
        value = find_attr_value_('userRealmName', node)
        if value is not None and 'userRealmName' not in already_processed:
            already_processed.add('userRealmName')
            self.userRealmName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
        elif nodeName_ == 'nodeSamlConfig':
            obj_ = NodeSamlConfig.factory()
            obj_.build(child_)
            self.nodeSamlConfig.append(obj_)
            obj_.original_tagname_ = 'nodeSamlConfig'
# end class SecurityConfig


class ServiceProcessStartupState(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, domainNode=None, serviceName=None, state=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.domainNode = _cast(None, domainNode)
        self.serviceName = _cast(None, serviceName)
        self.state = _cast(None, state)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceProcessStartupState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceProcessStartupState.subclass:
            return ServiceProcessStartupState.subclass(*args_, **kwargs_)
        else:
            return ServiceProcessStartupState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_domainNode(self): return self.domainNode
    def set_domainNode(self, domainNode): self.domainNode = domainNode
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ServiceProcessStartupState', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceProcessStartupState')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceProcessStartupState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ServiceProcessStartupState', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ServiceProcessStartupState'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.domainNode is not None and 'domainNode' not in already_processed:
            already_processed.add('domainNode')
            outfile.write(' domainNode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.domainNode), input_name='domainNode')), ))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceName), input_name='serviceName')), ))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (quote_attrib(self.state), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ServiceProcessStartupState', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('domainNode', node)
        if value is not None and 'domainNode' not in already_processed:
            already_processed.add('domainNode')
            self.domainNode = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class ServiceProcessStartupState


class ServiceStartupState(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, operationMode=None, serviceName=None, state=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.operationMode = _cast(None, operationMode)
        self.serviceName = _cast(None, serviceName)
        self.state = _cast(None, state)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceStartupState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceStartupState.subclass:
            return ServiceStartupState.subclass(*args_, **kwargs_)
        else:
            return ServiceStartupState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_operationMode(self): return self.operationMode
    def set_operationMode(self, operationMode): self.operationMode = operationMode
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ServiceStartupState', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceStartupState')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceStartupState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ServiceStartupState', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ServiceStartupState'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.operationMode is not None and 'operationMode' not in already_processed:
            already_processed.add('operationMode')
            outfile.write(' operationMode=%s' % (quote_attrib(self.operationMode), ))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceName), input_name='serviceName')), ))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (quote_attrib(self.state), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ServiceStartupState', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('operationMode', node)
        if value is not None and 'operationMode' not in already_processed:
            already_processed.add('operationMode')
            self.operationMode = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class ServiceStartupState


class ISPObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, annotations=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISPObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISPObject.subclass:
            return ISPObject.subclass(*args_, **kwargs_)
        else:
            return ISPObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ISPObject', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISPObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISPObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ISPObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ISPObject'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ISPObject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('imx:id', node)
        if value is not None and 'imx:id' not in already_processed:
            already_processed.add('imx:id')
            self.id = value
        value = find_attr_value_('imx:idref', node)
        if value is not None and 'imx:idref' not in already_processed:
            already_processed.add('imx:idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('imx:iid', node)
        if value is not None and 'imx:iid' not in already_processed:
            already_processed.add('imx:iid')
            self.iid = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class ISPObject


class ISPBoolean(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, value=None):
        self.original_tagname_ = None
        super(ISPBoolean, self).__init__(id, idref, iid, annotations, )
        self.value = _cast(bool, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISPBoolean)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISPBoolean.subclass:
            return ISPBoolean.subclass(*args_, **kwargs_)
        else:
            return ISPBoolean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            super(ISPBoolean, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ISPBoolean', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISPBoolean')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISPBoolean')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ISPBoolean', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ISPBoolean'):
        super(ISPBoolean, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISPBoolean')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_boolean(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ISPBoolean', fromsubclass_=False, pretty_print=True):
        super(ISPBoolean, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ISPBoolean, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ISPBoolean, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ISPBoolean


class ISPInteger(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, value=None):
        self.original_tagname_ = None
        super(ISPInteger, self).__init__(id, idref, iid, annotations, )
        self.value = _cast(int, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISPInteger)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISPInteger.subclass:
            return ISPInteger.subclass(*args_, **kwargs_)
        else:
            return ISPInteger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            super(ISPInteger, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ISPInteger', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISPInteger')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISPInteger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ISPInteger', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ISPInteger'):
        super(ISPInteger, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISPInteger')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ISPInteger', fromsubclass_=False, pretty_print=True):
        super(ISPInteger, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ISPInteger, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ISPInteger, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ISPInteger


class ISPLong(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, value=None):
        self.original_tagname_ = None
        super(ISPLong, self).__init__(id, idref, iid, annotations, )
        self.value = _cast(int, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISPLong)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISPLong.subclass:
            return ISPLong.subclass(*args_, **kwargs_)
        else:
            return ISPLong(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            super(ISPLong, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ISPLong', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISPLong')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISPLong')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ISPLong', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ISPLong'):
        super(ISPLong, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISPLong')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ISPLong', fromsubclass_=False, pretty_print=True):
        super(ISPLong, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ISPLong, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ISPLong, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ISPLong


class ISPNamedObject(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ISPNamedObject, self).__init__(id, idref, iid, annotations, extensiontype_, )
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISPNamedObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISPNamedObject.subclass:
            return ISPNamedObject.subclass(*args_, **kwargs_)
        else:
            return ISPNamedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ISPNamedObject, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ISPNamedObject', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISPNamedObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISPNamedObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ISPNamedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ISPNamedObject'):
        super(ISPNamedObject, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISPNamedObject')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ISPNamedObject', fromsubclass_=False, pretty_print=True):
        super(ISPNamedObject, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ISPNamedObject, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ISPNamedObject, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ISPNamedObject


class ISPString(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, string=None):
        self.original_tagname_ = None
        super(ISPString, self).__init__(id, idref, iid, annotations, )
        self.string = _cast(None, string)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISPString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISPString.subclass:
            return ISPString.subclass(*args_, **kwargs_)
        else:
            return ISPString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def hasContent_(self):
        if (
            super(ISPString, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ISPString', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISPString')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISPString')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ISPString', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ISPString'):
        super(ISPString, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISPString')
        if self.string is not None and 'string' not in already_processed:
            already_processed.add('string')
            outfile.write(' string=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.string), input_name='string')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ISPString', fromsubclass_=False, pretty_print=True):
        super(ISPString, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('string', node)
        if value is not None and 'string' not in already_processed:
            already_processed.add('string')
            self.string = value
        super(ISPString, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ISPString, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ISPString


class NodeAddress(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, host=None, httpPort=None, port=None):
        self.original_tagname_ = None
        super(NodeAddress, self).__init__(id, idref, iid, annotations, )
        self.host = _cast(None, host)
        self.httpPort = _cast(int, httpPort)
        self.port = _cast(int, port)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NodeAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NodeAddress.subclass:
            return NodeAddress.subclass(*args_, **kwargs_)
        else:
            return NodeAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self): return self.host
    def set_host(self, host): self.host = host
    def get_httpPort(self): return self.httpPort
    def set_httpPort(self, httpPort): self.httpPort = httpPort
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def hasContent_(self):
        if (
            super(NodeAddress, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='NodeAddress', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NodeAddress')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='NodeAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='NodeAddress'):
        super(NodeAddress, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NodeAddress')
        if self.host is not None and 'host' not in already_processed:
            already_processed.add('host')
            outfile.write(' host=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.host), input_name='host')), ))
        if self.httpPort is not None and 'httpPort' not in already_processed:
            already_processed.add('httpPort')
            outfile.write(' httpPort="%s"' % self.gds_format_integer(self.httpPort, input_name='httpPort'))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='NodeAddress', fromsubclass_=False, pretty_print=True):
        super(NodeAddress, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('host', node)
        if value is not None and 'host' not in already_processed:
            already_processed.add('host')
            self.host = value
        value = find_attr_value_('httpPort', node)
        if value is not None and 'httpPort' not in already_processed:
            already_processed.add('httpPort')
            try:
                self.httpPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            try:
                self.port = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(NodeAddress, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NodeAddress, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NodeAddress


class NodeRef(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, address=None, nodeName=None):
        self.original_tagname_ = None
        super(NodeRef, self).__init__(id, idref, iid, annotations, )
        self.address = _cast(None, address)
        self.nodeName = _cast(None, nodeName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NodeRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NodeRef.subclass:
            return NodeRef.subclass(*args_, **kwargs_)
        else:
            return NodeRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_nodeName(self): return self.nodeName
    def set_nodeName(self, nodeName): self.nodeName = nodeName
    def hasContent_(self):
        if (
            super(NodeRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='NodeRef', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NodeRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='NodeRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='NodeRef'):
        super(NodeRef, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NodeRef')
        if self.address is not None and 'address' not in already_processed:
            already_processed.add('address')
            outfile.write(' address=%s' % (quote_attrib(self.address), ))
        if self.nodeName is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            outfile.write(' nodeName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nodeName), input_name='nodeName')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='NodeRef', fromsubclass_=False, pretty_print=True):
        super(NodeRef, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.add('address')
            self.address = value
        value = find_attr_value_('nodeName', node)
        if value is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            self.nodeName = value
        super(NodeRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NodeRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NodeRef


class TimeOfDay(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, hourOfDay=None, minutes=None):
        self.original_tagname_ = None
        super(TimeOfDay, self).__init__(id, idref, iid, annotations, )
        self.hourOfDay = _cast(int, hourOfDay)
        self.minutes = _cast(int, minutes)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeOfDay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeOfDay.subclass:
            return TimeOfDay.subclass(*args_, **kwargs_)
        else:
            return TimeOfDay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourOfDay(self): return self.hourOfDay
    def set_hourOfDay(self, hourOfDay): self.hourOfDay = hourOfDay
    def get_minutes(self): return self.minutes
    def set_minutes(self, minutes): self.minutes = minutes
    def hasContent_(self):
        if (
            super(TimeOfDay, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='TimeOfDay', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeOfDay')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOfDay')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='TimeOfDay', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='TimeOfDay'):
        super(TimeOfDay, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOfDay')
        if self.hourOfDay is not None and 'hourOfDay' not in already_processed:
            already_processed.add('hourOfDay')
            outfile.write(' hourOfDay="%s"' % self.gds_format_integer(self.hourOfDay, input_name='hourOfDay'))
        if self.minutes is not None and 'minutes' not in already_processed:
            already_processed.add('minutes')
            outfile.write(' minutes="%s"' % self.gds_format_integer(self.minutes, input_name='minutes'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='TimeOfDay', fromsubclass_=False, pretty_print=True):
        super(TimeOfDay, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hourOfDay', node)
        if value is not None and 'hourOfDay' not in already_processed:
            already_processed.add('hourOfDay')
            try:
                self.hourOfDay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('minutes', node)
        if value is not None and 'minutes' not in already_processed:
            already_processed.add('minutes')
            try:
                self.minutes = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(TimeOfDay, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TimeOfDay, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TimeOfDay


class IdObj(ISPNamedObject):
    subclass = None
    superclass = ISPNamedObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, securityDomain=None):
        self.original_tagname_ = None
        super(IdObj, self).__init__(id, idref, iid, annotations, name, )
        self.securityDomain = _cast(None, securityDomain)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdObj)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdObj.subclass:
            return IdObj.subclass(*args_, **kwargs_)
        else:
            return IdObj(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_securityDomain(self): return self.securityDomain
    def set_securityDomain(self, securityDomain): self.securityDomain = securityDomain
    def hasContent_(self):
        if (
            super(IdObj, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='IdObj', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdObj')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdObj')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='IdObj', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='IdObj'):
        super(IdObj, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdObj')
        if self.securityDomain is not None and 'securityDomain' not in already_processed:
            already_processed.add('securityDomain')
            outfile.write(' securityDomain=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.securityDomain), input_name='securityDomain')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='IdObj', fromsubclass_=False, pretty_print=True):
        super(IdObj, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('securityDomain', node)
        if value is not None and 'securityDomain' not in already_processed:
            already_processed.add('securityDomain')
            self.securityDomain = value
        super(IdObj, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdObj, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdObj


class Option(ISPNamedObject):
    """Model Change Log 2.3.0 achauhan 04/9/2013 Added isSensitive option"""
    subclass = None
    superclass = ISPNamedObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, defaultValue=None, isModified=None, isSensitive=None, type_=None, value=None):
        self.original_tagname_ = None
        super(Option, self).__init__(id, idref, iid, annotations, name, )
        self.defaultValue = _cast(None, defaultValue)
        self.isModified = _cast(bool, isModified)
        self.isSensitive = _cast(bool, isSensitive)
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Option)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Option.subclass:
            return Option.subclass(*args_, **kwargs_)
        else:
            return Option(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_isModified(self): return self.isModified
    def set_isModified(self, isModified): self.isModified = isModified
    def get_isSensitive(self): return self.isSensitive
    def set_isSensitive(self, isSensitive): self.isSensitive = isSensitive
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            super(Option, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='Option', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Option')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Option')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='Option', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='Option'):
        super(Option, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Option')
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultValue), input_name='defaultValue')), ))
        if self.isModified is not None and 'isModified' not in already_processed:
            already_processed.add('isModified')
            outfile.write(' isModified="%s"' % self.gds_format_boolean(self.isModified, input_name='isModified'))
        if self.isSensitive is not None and 'isSensitive' not in already_processed:
            already_processed.add('isSensitive')
            outfile.write(' isSensitive="%s"' % self.gds_format_boolean(self.isSensitive, input_name='isSensitive'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='Option', fromsubclass_=False, pretty_print=True):
        super(Option, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            self.defaultValue = value
        value = find_attr_value_('isModified', node)
        if value is not None and 'isModified' not in already_processed:
            already_processed.add('isModified')
            if value in ('true', '1'):
                self.isModified = True
            elif value in ('false', '0'):
                self.isModified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isSensitive', node)
        if value is not None and 'isSensitive' not in already_processed:
            already_processed.add('isSensitive')
            if value in ('true', '1'):
                self.isSensitive = True
            elif value in ('false', '0'):
                self.isSensitive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(Option, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Option, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Option


class OptionGroup(ISPNamedObject):
    subclass = None
    superclass = ISPNamedObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, options=None):
        self.original_tagname_ = None
        super(OptionGroup, self).__init__(id, idref, iid, annotations, name, )
        if options is None:
            self.options = []
        else:
            self.options = options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionGroup.subclass:
            return OptionGroup.subclass(*args_, **kwargs_)
        else:
            return OptionGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_options(self): return self.options
    def set_options(self, options): self.options = options
    def add_options(self, value): self.options.append(value)
    def insert_options_at(self, index, value): self.options.insert(index, value)
    def replace_options_at(self, index, value): self.options[index] = value
    def hasContent_(self):
        if (
            self.options or
            super(OptionGroup, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='OptionGroup', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OptionGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='OptionGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='OptionGroup'):
        super(OptionGroup, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionGroup')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='OptionGroup', fromsubclass_=False, pretty_print=True):
        super(OptionGroup, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for options_ in self.options:
            options_.export(outfile, level, namespace_, name_='options', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionGroup, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'options':
            obj_ = optionsType.factory()
            obj_.build(child_)
            self.options.append(obj_)
            obj_.original_tagname_ = 'options'
        super(OptionGroup, self).buildChildren(child_, node, nodeName_, True)
# end class OptionGroup


class GroupRef(IdObj):
    subclass = None
    superclass = IdObj
    def __init__(self):
        self.original_tagname_ = None
        super(GroupRef, self).__init__()
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroupRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroupRef.subclass:
            return GroupRef.subclass(*args_, **kwargs_)
        else:
            return GroupRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GroupRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='GroupRef', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GroupRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='GroupRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='GroupRef'):
        super(GroupRef, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GroupRef')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='GroupRef', fromsubclass_=False, pretty_print=True):
        super(GroupRef, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GroupRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GroupRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GroupRef


class SensitiveOption(Option):
    subclass = None
    superclass = Option
    def __init__(self, sensitiveValue=None):
        self.original_tagname_ = None
        super(SensitiveOption, self).__init__()
        self.sensitiveValue = _cast(None, sensitiveValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SensitiveOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SensitiveOption.subclass:
            return SensitiveOption.subclass(*args_, **kwargs_)
        else:
            return SensitiveOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sensitiveValue(self): return self.sensitiveValue
    def set_sensitiveValue(self, sensitiveValue): self.sensitiveValue = sensitiveValue
    def hasContent_(self):
        if (
            super(SensitiveOption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='SensitiveOption', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SensitiveOption')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SensitiveOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='SensitiveOption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='SensitiveOption'):
        super(SensitiveOption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SensitiveOption')
        if self.sensitiveValue is not None and 'sensitiveValue' not in already_processed:
            already_processed.add('sensitiveValue')
            outfile.write(' sensitiveValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sensitiveValue), input_name='sensitiveValue')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='SensitiveOption', fromsubclass_=False, pretty_print=True):
        super(SensitiveOption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensitiveValue', node)
        if value is not None and 'sensitiveValue' not in already_processed:
            already_processed.add('sensitiveValue')
            self.sensitiveValue = value
        super(SensitiveOption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SensitiveOption, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SensitiveOption


class UserRef(IdObj):
    subclass = None
    superclass = IdObj
    def __init__(self):
        self.original_tagname_ = None
        super(UserRef, self).__init__()
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UserRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UserRef.subclass:
            return UserRef.subclass(*args_, **kwargs_)
        else:
            return UserRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(UserRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='UserRef', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UserRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='UserRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='UserRef'):
        super(UserRef, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UserRef')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='UserRef', fromsubclass_=False, pretty_print=True):
        super(UserRef, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UserRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(UserRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UserRef


class annotations(GeneratedsSuper):
    """Element which will contain the object level annotations attached on
    an object"""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotations.subclass:
            return annotations.subclass(*args_, **kwargs_)
        else:
            return annotations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='annotations', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('annotations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='annotations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='annotations'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='annotations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'annotations')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class annotations


class IBlob(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IBlob)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IBlob.subclass:
            return IBlob.subclass(*args_, **kwargs_)
        else:
            return IBlob(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='IBlob', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IBlob')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IBlob')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='IBlob', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='IBlob'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='IBlob', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IBlob


class IBlobs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IBlob=None):
        self.original_tagname_ = None
        if IBlob is None:
            self.IBlob = []
        else:
            self.IBlob = IBlob
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IBlobs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IBlobs.subclass:
            return IBlobs.subclass(*args_, **kwargs_)
        else:
            return IBlobs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IBlob(self): return self.IBlob
    def set_IBlob(self, IBlob): self.IBlob = IBlob
    def add_IBlob(self, value): self.IBlob.append(value)
    def insert_IBlob_at(self, index, value): self.IBlob.insert(index, value)
    def replace_IBlob_at(self, index, value): self.IBlob[index] = value
    def hasContent_(self):
        if (
            self.IBlob
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='IBlobs', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IBlobs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IBlobs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='IBlobs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='IBlobs'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='IBlobs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IBlob_ in self.IBlob:
            IBlob_.export(outfile, level, namespace_, name_='IBlob', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IBlob':
            obj_ = IBlob.factory()
            obj_.build(child_)
            self.IBlob.append(obj_)
            obj_.original_tagname_ = 'IBlob'
# end class IBlobs


class proxy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, locator=None, type_=None, objectId=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.locator = _cast(None, locator)
        self.type_ = _cast(None, type_)
        self.objectId = _cast(None, objectId)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, proxy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if proxy.subclass:
            return proxy.subclass(*args_, **kwargs_)
        else:
            return proxy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_locator(self): return self.locator
    def set_locator(self, locator): self.locator = locator
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_objectId(self): return self.objectId
    def set_objectId(self, objectId): self.objectId = objectId
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='proxy', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('proxy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='proxy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='proxy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='proxy'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.locator is not None and 'locator' not in already_processed:
            already_processed.add('locator')
            outfile.write(' locator=%s' % (quote_attrib(self.locator), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.objectId is not None and 'objectId' not in already_processed:
            already_processed.add('objectId')
            outfile.write(' objectId=%s' % (quote_attrib(self.objectId), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='proxy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('locator', node)
        if value is not None and 'locator' not in already_processed:
            already_processed.add('locator')
            self.locator = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('objectId', node)
        if value is not None and 'objectId' not in already_processed:
            already_processed.add('objectId')
            self.objectId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class proxy


class proxies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, proxy=None):
        self.original_tagname_ = None
        if proxy is None:
            self.proxy = []
        else:
            self.proxy = proxy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, proxies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if proxies.subclass:
            return proxies.subclass(*args_, **kwargs_)
        else:
            return proxies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_proxy(self): return self.proxy
    def set_proxy(self, proxy): self.proxy = proxy
    def add_proxy(self, value): self.proxy.append(value)
    def insert_proxy_at(self, index, value): self.proxy.insert(index, value)
    def replace_proxy_at(self, index, value): self.proxy[index] = value
    def hasContent_(self):
        if (
            self.proxy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='proxies', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('proxies')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='proxies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='proxies', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='proxies'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='proxies', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for proxy_ in self.proxy:
            proxy_.export(outfile, level, namespace_, name_='proxy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'proxy':
            obj_ = proxy.factory()
            obj_.build(child_)
            self.proxy.append(obj_)
            obj_.original_tagname_ = 'proxy'
# end class proxies


class IGenericAnnotations(GeneratedsSuper):
    """Element which will contain generic annotations attached on an object"""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IGenericAnnotations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IGenericAnnotations.subclass:
            return IGenericAnnotations.subclass(*args_, **kwargs_)
        else:
            return IGenericAnnotations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='IGenericAnnotations', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IGenericAnnotations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IGenericAnnotations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='IGenericAnnotations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='IGenericAnnotations'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='IGenericAnnotations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'IGenericAnnotations')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class IGenericAnnotations


class crc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, crc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if crc.subclass:
            return crc.subclass(*args_, **kwargs_)
        else:
            return crc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='crc', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('crc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='crc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='crc'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='crc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class crc


class IMX(GeneratedsSuper):
    """Note : Update target package version in \n com.informatica.isp.infas
    etup.impl.upgrader.ApplicationServiceUpgradeCallback upgrade
    callback handler \n if you change package version here.\n\n
    Change logs:\n Added EarlierVersionDomainObjRefs in version
    2.8.1 from 2.8.0\n"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMX)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMX.subclass:
            return IMX.subclass(*args_, **kwargs_)
        else:
            return IMX(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='IMX', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMX')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMX')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='IMX', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='IMX'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='IMX', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IMX


class Command(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, command=None, commandTimeout=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.command = _cast(None, command)
        self.commandTimeout = _cast(int, commandTimeout)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Command)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Command.subclass:
            return Command.subclass(*args_, **kwargs_)
        else:
            return Command(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_command(self): return self.command
    def set_command(self, command): self.command = command
    def get_commandTimeout(self): return self.commandTimeout
    def set_commandTimeout(self, commandTimeout): self.commandTimeout = commandTimeout
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='Command', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Command')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Command')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='Command', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='Command'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.command is not None and 'command' not in already_processed:
            already_processed.add('command')
            outfile.write(' command=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.command), input_name='command')), ))
        if self.commandTimeout is not None and 'commandTimeout' not in already_processed:
            already_processed.add('commandTimeout')
            outfile.write(' commandTimeout="%s"' % self.gds_format_integer(self.commandTimeout, input_name='commandTimeout'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='Command', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('command', node)
        if value is not None and 'command' not in already_processed:
            already_processed.add('command')
            self.command = value
        value = find_attr_value_('commandTimeout', node)
        if value is not None and 'commandTimeout' not in already_processed:
            already_processed.add('commandTimeout')
            try:
                self.commandTimeout = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class Command


class ComputeNodeConfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, nodeName=None, annotations=None, options=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.nodeName = _cast(None, nodeName)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
        if options is None:
            self.options = []
        else:
            self.options = options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComputeNodeConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComputeNodeConfiguration.subclass:
            return ComputeNodeConfiguration.subclass(*args_, **kwargs_)
        else:
            return ComputeNodeConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_options(self): return self.options
    def set_options(self, options): self.options = options
    def add_options(self, value): self.options.append(value)
    def insert_options_at(self, index, value): self.options.insert(index, value)
    def replace_options_at(self, index, value): self.options[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_nodeName(self): return self.nodeName
    def set_nodeName(self, nodeName): self.nodeName = nodeName
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations or
            self.options
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ComputeNodeConfiguration', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComputeNodeConfiguration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeNodeConfiguration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ComputeNodeConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ComputeNodeConfiguration'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.nodeName is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            outfile.write(' nodeName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nodeName), input_name='nodeName')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ComputeNodeConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
        for options_ in self.options:
            options_.export(outfile, level, namespace_, name_='options', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('nodeName', node)
        if value is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            self.nodeName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
        elif nodeName_ == 'options':
            obj_ = optionsType1.factory()
            obj_.build(child_)
            self.options.append(obj_)
            obj_.original_tagname_ = 'options'
# end class ComputeNodeConfiguration


class DomainObjectLocate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, objName=None, objType=None, permission=None, serviceType=None, annotations=None, folderObjects=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.objName = _cast(None, objName)
        self.objType = _cast(None, objType)
        self.permission = _cast(bool, permission)
        self.serviceType = _cast(None, serviceType)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
        if folderObjects is None:
            self.folderObjects = []
        else:
            self.folderObjects = folderObjects
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomainObjectLocate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomainObjectLocate.subclass:
            return DomainObjectLocate.subclass(*args_, **kwargs_)
        else:
            return DomainObjectLocate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_folderObjects(self): return self.folderObjects
    def set_folderObjects(self, folderObjects): self.folderObjects = folderObjects
    def add_folderObjects(self, value): self.folderObjects.append(value)
    def insert_folderObjects_at(self, index, value): self.folderObjects.insert(index, value)
    def replace_folderObjects_at(self, index, value): self.folderObjects[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_objName(self): return self.objName
    def set_objName(self, objName): self.objName = objName
    def get_objType(self): return self.objType
    def set_objType(self, objType): self.objType = objType
    def get_permission(self): return self.permission
    def set_permission(self, permission): self.permission = permission
    def get_serviceType(self): return self.serviceType
    def set_serviceType(self, serviceType): self.serviceType = serviceType
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations or
            self.folderObjects
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='DomainObjectLocate', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DomainObjectLocate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainObjectLocate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='DomainObjectLocate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='DomainObjectLocate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.objName is not None and 'objName' not in already_processed:
            already_processed.add('objName')
            outfile.write(' objName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.objName), input_name='objName')), ))
        if self.objType is not None and 'objType' not in already_processed:
            already_processed.add('objType')
            outfile.write(' objType=%s' % (quote_attrib(self.objType), ))
        if self.permission is not None and 'permission' not in already_processed:
            already_processed.add('permission')
            outfile.write(' permission="%s"' % self.gds_format_boolean(self.permission, input_name='permission'))
        if self.serviceType is not None and 'serviceType' not in already_processed:
            already_processed.add('serviceType')
            outfile.write(' serviceType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceType), input_name='serviceType')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='DomainObjectLocate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
        for folderObjects_ in self.folderObjects:
            folderObjects_.export(outfile, level, namespace_, name_='folderObjects', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('objName', node)
        if value is not None and 'objName' not in already_processed:
            already_processed.add('objName')
            self.objName = value
        value = find_attr_value_('objType', node)
        if value is not None and 'objType' not in already_processed:
            already_processed.add('objType')
            self.objType = value
        value = find_attr_value_('permission', node)
        if value is not None and 'permission' not in already_processed:
            already_processed.add('permission')
            if value in ('true', '1'):
                self.permission = True
            elif value in ('false', '0'):
                self.permission = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('serviceType', node)
        if value is not None and 'serviceType' not in already_processed:
            already_processed.add('serviceType')
            self.serviceType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
        elif nodeName_ == 'folderObjects':
            obj_ = folderObjectsType.factory()
            obj_.build(child_)
            self.folderObjects.append(obj_)
            obj_.original_tagname_ = 'folderObjects'
# end class DomainObjectLocate


class RoleTypeContainer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, idref=None, iid=None, roleType=None, annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.idref = _cast(None, idref)
        self.iid = _cast(None, iid)
        self.roleType = _cast(None, roleType)
        if annotations is None:
            self.annotations = []
        else:
            self.annotations = annotations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoleTypeContainer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoleTypeContainer.subclass:
            return RoleTypeContainer.subclass(*args_, **kwargs_)
        else:
            return RoleTypeContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotations(self): return self.annotations
    def set_annotations(self, annotations): self.annotations = annotations
    def add_annotations(self, value): self.annotations.append(value)
    def insert_annotations_at(self, index, value): self.annotations.insert(index, value)
    def replace_annotations_at(self, index, value): self.annotations[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_iid(self): return self.iid
    def set_iid(self, iid): self.iid = iid
    def get_roleType(self): return self.roleType
    def set_roleType(self, roleType): self.roleType = roleType
    def validate_idref(self, value):
        # Validate type idref, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.annotations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='RoleTypeContainer', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:imx="http://com.informatica.imx" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RoleTypeContainer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoleTypeContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='RoleTypeContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='RoleTypeContainer'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.iid is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            outfile.write(' iid=%s' % (quote_attrib(self.iid), ))
        if self.roleType is not None and 'roleType' not in already_processed:
            already_processed.add('roleType')
            outfile.write(' roleType=%s' % (quote_attrib(self.roleType), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='RoleTypeContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotations_ in self.annotations:
            annotations_.export(outfile, level, namespace_='imx:', name_='annotations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_idref(self.idref)    # validate type idref
        value = find_attr_value_('iid', node)
        if value is not None and 'iid' not in already_processed:
            already_processed.add('iid')
            self.iid = value
        value = find_attr_value_('roleType', node)
        if value is not None and 'roleType' not in already_processed:
            already_processed.add('roleType')
            self.roleType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotations':
            obj_ = annotations.factory()
            obj_.build(child_)
            self.annotations.append(obj_)
            obj_.original_tagname_ = 'annotations'
# end class RoleTypeContainer


class NodeCapability(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, type_=None, resources=None):
        self.original_tagname_ = None
        super(NodeCapability, self).__init__(id, idref, iid, annotations, )
        self.type_ = _cast(None, type_)
        if resources is None:
            self.resources = []
        else:
            self.resources = resources
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NodeCapability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NodeCapability.subclass:
            return NodeCapability.subclass(*args_, **kwargs_)
        else:
            return NodeCapability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resources(self): return self.resources
    def set_resources(self, resources): self.resources = resources
    def add_resources(self, value): self.resources.append(value)
    def insert_resources_at(self, index, value): self.resources.insert(index, value)
    def replace_resources_at(self, index, value): self.resources[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.resources or
            super(NodeCapability, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='NodeCapability', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NodeCapability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeCapability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='NodeCapability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='NodeCapability'):
        super(NodeCapability, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NodeCapability')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='NodeCapability', fromsubclass_=False, pretty_print=True):
        super(NodeCapability, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for resources_ in self.resources:
            resources_.export(outfile, level, namespace_, name_='resources', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(NodeCapability, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resources':
            obj_ = resourcesType2.factory()
            obj_.build(child_)
            self.resources.append(obj_)
            obj_.original_tagname_ = 'resources'
        super(NodeCapability, self).buildChildren(child_, node, nodeName_, True)
# end class NodeCapability


class Process(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, jvmOptions=None, node=None, primaryProcess=None, envVariables=None, internalProcessOptions=None, postStartCommand=None, preStartCommand=None, processOptions=None):
        self.original_tagname_ = None
        super(Process, self).__init__(id, idref, iid, annotations, )
        self.jvmOptions = _cast(None, jvmOptions)
        self.node = _cast(None, node)
        self.primaryProcess = _cast(bool, primaryProcess)
        if envVariables is None:
            self.envVariables = []
        else:
            self.envVariables = envVariables
        if internalProcessOptions is None:
            self.internalProcessOptions = []
        else:
            self.internalProcessOptions = internalProcessOptions
        if postStartCommand is None:
            self.postStartCommand = []
        else:
            self.postStartCommand = postStartCommand
        if preStartCommand is None:
            self.preStartCommand = []
        else:
            self.preStartCommand = preStartCommand
        if processOptions is None:
            self.processOptions = []
        else:
            self.processOptions = processOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Process)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Process.subclass:
            return Process.subclass(*args_, **kwargs_)
        else:
            return Process(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_envVariables(self): return self.envVariables
    def set_envVariables(self, envVariables): self.envVariables = envVariables
    def add_envVariables(self, value): self.envVariables.append(value)
    def insert_envVariables_at(self, index, value): self.envVariables.insert(index, value)
    def replace_envVariables_at(self, index, value): self.envVariables[index] = value
    def get_internalProcessOptions(self): return self.internalProcessOptions
    def set_internalProcessOptions(self, internalProcessOptions): self.internalProcessOptions = internalProcessOptions
    def add_internalProcessOptions(self, value): self.internalProcessOptions.append(value)
    def insert_internalProcessOptions_at(self, index, value): self.internalProcessOptions.insert(index, value)
    def replace_internalProcessOptions_at(self, index, value): self.internalProcessOptions[index] = value
    def get_postStartCommand(self): return self.postStartCommand
    def set_postStartCommand(self, postStartCommand): self.postStartCommand = postStartCommand
    def add_postStartCommand(self, value): self.postStartCommand.append(value)
    def insert_postStartCommand_at(self, index, value): self.postStartCommand.insert(index, value)
    def replace_postStartCommand_at(self, index, value): self.postStartCommand[index] = value
    def get_preStartCommand(self): return self.preStartCommand
    def set_preStartCommand(self, preStartCommand): self.preStartCommand = preStartCommand
    def add_preStartCommand(self, value): self.preStartCommand.append(value)
    def insert_preStartCommand_at(self, index, value): self.preStartCommand.insert(index, value)
    def replace_preStartCommand_at(self, index, value): self.preStartCommand[index] = value
    def get_processOptions(self): return self.processOptions
    def set_processOptions(self, processOptions): self.processOptions = processOptions
    def add_processOptions(self, value): self.processOptions.append(value)
    def insert_processOptions_at(self, index, value): self.processOptions.insert(index, value)
    def replace_processOptions_at(self, index, value): self.processOptions[index] = value
    def get_jvmOptions(self): return self.jvmOptions
    def set_jvmOptions(self, jvmOptions): self.jvmOptions = jvmOptions
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def get_primaryProcess(self): return self.primaryProcess
    def set_primaryProcess(self, primaryProcess): self.primaryProcess = primaryProcess
    def hasContent_(self):
        if (
            self.envVariables or
            self.internalProcessOptions or
            self.postStartCommand or
            self.preStartCommand or
            self.processOptions or
            super(Process, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='Process', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Process')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Process')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='Process', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='Process'):
        super(Process, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Process')
        if self.jvmOptions is not None and 'jvmOptions' not in already_processed:
            already_processed.add('jvmOptions')
            outfile.write(' jvmOptions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.jvmOptions), input_name='jvmOptions')), ))
        if self.node is not None and 'node' not in already_processed:
            already_processed.add('node')
            outfile.write(' node=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.node), input_name='node')), ))
        if self.primaryProcess is not None and 'primaryProcess' not in already_processed:
            already_processed.add('primaryProcess')
            outfile.write(' primaryProcess="%s"' % self.gds_format_boolean(self.primaryProcess, input_name='primaryProcess'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='Process', fromsubclass_=False, pretty_print=True):
        super(Process, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for envVariables_ in self.envVariables:
            envVariables_.export(outfile, level, namespace_, name_='envVariables', pretty_print=pretty_print)
        for internalProcessOptions_ in self.internalProcessOptions:
            internalProcessOptions_.export(outfile, level, namespace_, name_='internalProcessOptions', pretty_print=pretty_print)
        for postStartCommand_ in self.postStartCommand:
            postStartCommand_.export(outfile, level, namespace_, name_='postStartCommand', pretty_print=pretty_print)
        for preStartCommand_ in self.preStartCommand:
            preStartCommand_.export(outfile, level, namespace_, name_='preStartCommand', pretty_print=pretty_print)
        for processOptions_ in self.processOptions:
            processOptions_.export(outfile, level, namespace_, name_='processOptions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('jvmOptions', node)
        if value is not None and 'jvmOptions' not in already_processed:
            already_processed.add('jvmOptions')
            self.jvmOptions = value
        value = find_attr_value_('node', node)
        if value is not None and 'node' not in already_processed:
            already_processed.add('node')
            self.node = value
        value = find_attr_value_('primaryProcess', node)
        if value is not None and 'primaryProcess' not in already_processed:
            already_processed.add('primaryProcess')
            if value in ('true', '1'):
                self.primaryProcess = True
            elif value in ('false', '0'):
                self.primaryProcess = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(Process, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'envVariables':
            obj_ = envVariablesType.factory()
            obj_.build(child_)
            self.envVariables.append(obj_)
            obj_.original_tagname_ = 'envVariables'
        elif nodeName_ == 'internalProcessOptions':
            obj_ = internalProcessOptionsType.factory()
            obj_.build(child_)
            self.internalProcessOptions.append(obj_)
            obj_.original_tagname_ = 'internalProcessOptions'
        elif nodeName_ == 'postStartCommand':
            obj_ = Command.factory()
            obj_.build(child_)
            self.postStartCommand.append(obj_)
            obj_.original_tagname_ = 'postStartCommand'
        elif nodeName_ == 'preStartCommand':
            obj_ = Command.factory()
            obj_.build(child_)
            self.preStartCommand.append(obj_)
            obj_.original_tagname_ = 'preStartCommand'
        elif nodeName_ == 'processOptions':
            obj_ = processOptionsType.factory()
            obj_.build(child_)
            self.processOptions.append(obj_)
            obj_.original_tagname_ = 'processOptions'
        super(Process, self).buildChildren(child_, node, nodeName_, True)
# end class Process


class ServiceRef(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, domainName=None, serviceName=None, serviceRefType=None, options=None):
        self.original_tagname_ = None
        super(ServiceRef, self).__init__(id, idref, iid, annotations, )
        self.domainName = _cast(None, domainName)
        self.serviceName = _cast(None, serviceName)
        self.serviceRefType = _cast(None, serviceRefType)
        if options is None:
            self.options = []
        else:
            self.options = options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRef.subclass:
            return ServiceRef.subclass(*args_, **kwargs_)
        else:
            return ServiceRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_options(self): return self.options
    def set_options(self, options): self.options = options
    def add_options(self, value): self.options.append(value)
    def insert_options_at(self, index, value): self.options.insert(index, value)
    def replace_options_at(self, index, value): self.options[index] = value
    def get_domainName(self): return self.domainName
    def set_domainName(self, domainName): self.domainName = domainName
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_serviceRefType(self): return self.serviceRefType
    def set_serviceRefType(self, serviceRefType): self.serviceRefType = serviceRefType
    def hasContent_(self):
        if (
            self.options or
            super(ServiceRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ServiceRef', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ServiceRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ServiceRef'):
        super(ServiceRef, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceRef')
        if self.domainName is not None and 'domainName' not in already_processed:
            already_processed.add('domainName')
            outfile.write(' domainName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.domainName), input_name='domainName')), ))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceName), input_name='serviceName')), ))
        if self.serviceRefType is not None and 'serviceRefType' not in already_processed:
            already_processed.add('serviceRefType')
            outfile.write(' serviceRefType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceRefType), input_name='serviceRefType')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ServiceRef', fromsubclass_=False, pretty_print=True):
        super(ServiceRef, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for options_ in self.options:
            options_.export(outfile, level, namespace_, name_='options', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('domainName', node)
        if value is not None and 'domainName' not in already_processed:
            already_processed.add('domainName')
            self.domainName = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('serviceRefType', node)
        if value is not None and 'serviceRefType' not in already_processed:
            already_processed.add('serviceRefType')
            self.serviceRefType = value
        super(ServiceRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'options':
            obj_ = optionsType3.factory()
            obj_.build(child_)
            self.options.append(obj_)
            obj_.original_tagname_ = 'options'
        super(ServiceRef, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceRef


class CppProcess(Process):
    subclass = None
    superclass = Process
    def __init__(self):
        self.original_tagname_ = None
        super(CppProcess, self).__init__()
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CppProcess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CppProcess.subclass:
            return CppProcess.subclass(*args_, **kwargs_)
        else:
            return CppProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CppProcess, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='CppProcess', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CppProcess')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CppProcess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='CppProcess', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='CppProcess'):
        super(CppProcess, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CppProcess')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='CppProcess', fromsubclass_=False, pretty_print=True):
        super(CppProcess, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CppProcess, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CppProcess, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CppProcess


class DomainObj(ISPNamedObject):
    """Model Change Log 2.6.0 dchhatan 19/8/2013 For property description:
    Changed the persistence size to LengthTypeMax.UNBOUNDED Changed
    Length to LengthType.UNBOUNDED To support unbounded length of
    description"""
    subclass = None
    superclass = ISPNamedObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, description=None, extensiontype_=None):
        self.original_tagname_ = None
        super(DomainObj, self).__init__(id, idref, iid, annotations, name, extensiontype_, )
        self.description = _cast(None, description)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomainObj)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomainObj.subclass:
            return DomainObj.subclass(*args_, **kwargs_)
        else:
            return DomainObj(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(DomainObj, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='DomainObj', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DomainObj')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainObj')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='DomainObj', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='DomainObj'):
        super(DomainObj, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DomainObj')
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='DomainObj', fromsubclass_=False, pretty_print=True):
        super(DomainObj, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DomainObj, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DomainObj, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DomainObj


class EarlierVersionDomainObjRefs(GeneratedsSuper):
    """EarlierVersionDomainObjRefs maintains a list of domain object
    identities. The domain objects were restored from an earlier
    version of product release such as 9.6.1 to the current version
    of product release. The identities of those objects are put into
    this container through an explicit infasetup command after
    upgrade operation is performed. An identity of a domain object
    remain in this container until all the runtime behavior
    associated object has been migrated to the current version of
    product release. The identity is removed from this container
    upon explicit request. If the container exists and the list is
    empty, it means that all domain objects have been migrated. If
    the container itself does not exist, it means restore procedure
    did not explicitly request to mark the domain objects for
    migration. @author pdas"""
    subclass = None
    superclass = None
    def __init__(self, objIds=None):
        self.original_tagname_ = None
        self.objIds = _cast(None, objIds)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EarlierVersionDomainObjRefs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EarlierVersionDomainObjRefs.subclass:
            return EarlierVersionDomainObjRefs.subclass(*args_, **kwargs_)
        else:
            return EarlierVersionDomainObjRefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_objIds(self): return self.objIds
    def set_objIds(self, objIds): self.objIds = objIds
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='EarlierVersionDomainObjRefs', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EarlierVersionDomainObjRefs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EarlierVersionDomainObjRefs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='EarlierVersionDomainObjRefs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='EarlierVersionDomainObjRefs'):
        if self.objIds is not None and 'objIds' not in already_processed:
            already_processed.add('objIds')
            outfile.write(' objIds=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.objIds), input_name='objIds')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='EarlierVersionDomainObjRefs', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('objIds', node)
        if value is not None and 'objIds' not in already_processed:
            already_processed.add('objIds')
            self.objIds = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EarlierVersionDomainObjRefs, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EarlierVersionDomainObjRefs


class ExecutableProcess(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, base64Encode=None, commandArguments=None, commandName=None):
        self.original_tagname_ = None
        self.base64Encode = _cast(bool, base64Encode)
        self.commandArguments = _cast(None, commandArguments)
        self.commandName = _cast(None, commandName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExecutableProcess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExecutableProcess.subclass:
            return ExecutableProcess.subclass(*args_, **kwargs_)
        else:
            return ExecutableProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_base64Encode(self): return self.base64Encode
    def set_base64Encode(self, base64Encode): self.base64Encode = base64Encode
    def get_commandArguments(self): return self.commandArguments
    def set_commandArguments(self, commandArguments): self.commandArguments = commandArguments
    def get_commandName(self): return self.commandName
    def set_commandName(self, commandName): self.commandName = commandName
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ExecutableProcess', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExecutableProcess')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutableProcess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ExecutableProcess', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ExecutableProcess'):
        if self.base64Encode is not None and 'base64Encode' not in already_processed:
            already_processed.add('base64Encode')
            outfile.write(' base64Encode="%s"' % self.gds_format_boolean(self.base64Encode, input_name='base64Encode'))
        if self.commandArguments is not None and 'commandArguments' not in already_processed:
            already_processed.add('commandArguments')
            outfile.write(' commandArguments=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.commandArguments), input_name='commandArguments')), ))
        if self.commandName is not None and 'commandName' not in already_processed:
            already_processed.add('commandName')
            outfile.write(' commandName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.commandName), input_name='commandName')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ExecutableProcess', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('base64Encode', node)
        if value is not None and 'base64Encode' not in already_processed:
            already_processed.add('base64Encode')
            if value in ('true', '1'):
                self.base64Encode = True
            elif value in ('false', '0'):
                self.base64Encode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('commandArguments', node)
        if value is not None and 'commandArguments' not in already_processed:
            already_processed.add('commandArguments')
            self.commandArguments = value
        value = find_attr_value_('commandName', node)
        if value is not None and 'commandName' not in already_processed:
            already_processed.add('commandName')
            self.commandName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExecutableProcess, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExecutableProcess


class JSFProcess(Process):
    subclass = None
    superclass = Process
    def __init__(self):
        self.original_tagname_ = None
        super(JSFProcess, self).__init__()
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, JSFProcess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if JSFProcess.subclass:
            return JSFProcess.subclass(*args_, **kwargs_)
        else:
            return JSFProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(JSFProcess, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='JSFProcess', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('JSFProcess')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JSFProcess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='JSFProcess', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='JSFProcess'):
        super(JSFProcess, self).exportAttributes(outfile, level, already_processed, namespace_, name_='JSFProcess')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='JSFProcess', fromsubclass_=False, pretty_print=True):
        super(JSFProcess, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(JSFProcess, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(JSFProcess, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class JSFProcess


class NodeResource(ISPNamedObject):
    subclass = None
    superclass = ISPNamedObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, available=None, type_=None):
        self.original_tagname_ = None
        super(NodeResource, self).__init__(id, idref, iid, annotations, name, )
        self.available = _cast(bool, available)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NodeResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NodeResource.subclass:
            return NodeResource.subclass(*args_, **kwargs_)
        else:
            return NodeResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_available(self): return self.available
    def set_available(self, available): self.available = available
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            super(NodeResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='NodeResource', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NodeResource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='NodeResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='NodeResource'):
        super(NodeResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NodeResource')
        if self.available is not None and 'available' not in already_processed:
            already_processed.add('available')
            outfile.write(' available="%s"' % self.gds_format_boolean(self.available, input_name='available'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='NodeResource', fromsubclass_=False, pretty_print=True):
        super(NodeResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('available', node)
        if value is not None and 'available' not in already_processed:
            already_processed.add('available')
            if value in ('true', '1'):
                self.available = True
            elif value in ('false', '0'):
                self.available = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(NodeResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NodeResource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NodeResource


class ResourceString(ISPNamedObject):
    subclass = None
    superclass = ISPNamedObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, available=None):
        self.original_tagname_ = None
        super(ResourceString, self).__init__(id, idref, iid, annotations, name, )
        self.available = _cast(bool, available)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceString.subclass:
            return ResourceString.subclass(*args_, **kwargs_)
        else:
            return ResourceString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_available(self): return self.available
    def set_available(self, available): self.available = available
    def hasContent_(self):
        if (
            super(ResourceString, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ResourceString', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceString')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceString')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ResourceString', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ResourceString'):
        super(ResourceString, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceString')
        if self.available is not None and 'available' not in already_processed:
            already_processed.add('available')
            outfile.write(' available="%s"' % self.gds_format_boolean(self.available, input_name='available'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ResourceString', fromsubclass_=False, pretty_print=True):
        super(ResourceString, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('available', node)
        if value is not None and 'available' not in already_processed:
            already_processed.add('available')
            if value in ('true', '1'):
                self.available = True
            elif value in ('false', '0'):
                self.available = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ResourceString, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResourceString, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResourceString


class WebAppProcess(Process):
    """MODIFICATIONS 2.4.0 mpoon 08/30/2012 Added new properties
    'truststoreFile' and 'truststorePassword'"""
    subclass = None
    superclass = Process
    def __init__(self, algorithm=None, httpPort=None, httpsPort=None, keystoreFile=None, keystorePassword=None, maxQueue=None, maxRequests=None, shutdownPort=None, sslProtocol=None, truststoreFile=None, truststorePassword=None):
        self.original_tagname_ = None
        super(WebAppProcess, self).__init__()
        self.algorithm = _cast(None, algorithm)
        self.httpPort = _cast(int, httpPort)
        self.httpsPort = _cast(int, httpsPort)
        self.keystoreFile = _cast(None, keystoreFile)
        self.keystorePassword = _cast(None, keystorePassword)
        self.maxQueue = _cast(int, maxQueue)
        self.maxRequests = _cast(int, maxRequests)
        self.shutdownPort = _cast(int, shutdownPort)
        self.sslProtocol = _cast(None, sslProtocol)
        self.truststoreFile = _cast(None, truststoreFile)
        self.truststorePassword = _cast(None, truststorePassword)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppProcess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppProcess.subclass:
            return WebAppProcess.subclass(*args_, **kwargs_)
        else:
            return WebAppProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def get_httpPort(self): return self.httpPort
    def set_httpPort(self, httpPort): self.httpPort = httpPort
    def get_httpsPort(self): return self.httpsPort
    def set_httpsPort(self, httpsPort): self.httpsPort = httpsPort
    def get_keystoreFile(self): return self.keystoreFile
    def set_keystoreFile(self, keystoreFile): self.keystoreFile = keystoreFile
    def get_keystorePassword(self): return self.keystorePassword
    def set_keystorePassword(self, keystorePassword): self.keystorePassword = keystorePassword
    def get_maxQueue(self): return self.maxQueue
    def set_maxQueue(self, maxQueue): self.maxQueue = maxQueue
    def get_maxRequests(self): return self.maxRequests
    def set_maxRequests(self, maxRequests): self.maxRequests = maxRequests
    def get_shutdownPort(self): return self.shutdownPort
    def set_shutdownPort(self, shutdownPort): self.shutdownPort = shutdownPort
    def get_sslProtocol(self): return self.sslProtocol
    def set_sslProtocol(self, sslProtocol): self.sslProtocol = sslProtocol
    def get_truststoreFile(self): return self.truststoreFile
    def set_truststoreFile(self, truststoreFile): self.truststoreFile = truststoreFile
    def get_truststorePassword(self): return self.truststorePassword
    def set_truststorePassword(self, truststorePassword): self.truststorePassword = truststorePassword
    def hasContent_(self):
        if (
            super(WebAppProcess, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='WebAppProcess', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppProcess')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WebAppProcess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='WebAppProcess', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='WebAppProcess'):
        super(WebAppProcess, self).exportAttributes(outfile, level, already_processed, namespace_, name_='WebAppProcess')
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            outfile.write(' algorithm=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithm), input_name='algorithm')), ))
        if self.httpPort is not None and 'httpPort' not in already_processed:
            already_processed.add('httpPort')
            outfile.write(' httpPort="%s"' % self.gds_format_integer(self.httpPort, input_name='httpPort'))
        if self.httpsPort is not None and 'httpsPort' not in already_processed:
            already_processed.add('httpsPort')
            outfile.write(' httpsPort="%s"' % self.gds_format_integer(self.httpsPort, input_name='httpsPort'))
        if self.keystoreFile is not None and 'keystoreFile' not in already_processed:
            already_processed.add('keystoreFile')
            outfile.write(' keystoreFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keystoreFile), input_name='keystoreFile')), ))
        if self.keystorePassword is not None and 'keystorePassword' not in already_processed:
            already_processed.add('keystorePassword')
            outfile.write(' keystorePassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keystorePassword), input_name='keystorePassword')), ))
        if self.maxQueue is not None and 'maxQueue' not in already_processed:
            already_processed.add('maxQueue')
            outfile.write(' maxQueue="%s"' % self.gds_format_integer(self.maxQueue, input_name='maxQueue'))
        if self.maxRequests is not None and 'maxRequests' not in already_processed:
            already_processed.add('maxRequests')
            outfile.write(' maxRequests="%s"' % self.gds_format_integer(self.maxRequests, input_name='maxRequests'))
        if self.shutdownPort is not None and 'shutdownPort' not in already_processed:
            already_processed.add('shutdownPort')
            outfile.write(' shutdownPort="%s"' % self.gds_format_integer(self.shutdownPort, input_name='shutdownPort'))
        if self.sslProtocol is not None and 'sslProtocol' not in already_processed:
            already_processed.add('sslProtocol')
            outfile.write(' sslProtocol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sslProtocol), input_name='sslProtocol')), ))
        if self.truststoreFile is not None and 'truststoreFile' not in already_processed:
            already_processed.add('truststoreFile')
            outfile.write(' truststoreFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.truststoreFile), input_name='truststoreFile')), ))
        if self.truststorePassword is not None and 'truststorePassword' not in already_processed:
            already_processed.add('truststorePassword')
            outfile.write(' truststorePassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.truststorePassword), input_name='truststorePassword')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='WebAppProcess', fromsubclass_=False, pretty_print=True):
        super(WebAppProcess, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            self.algorithm = value
        value = find_attr_value_('httpPort', node)
        if value is not None and 'httpPort' not in already_processed:
            already_processed.add('httpPort')
            try:
                self.httpPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('httpsPort', node)
        if value is not None and 'httpsPort' not in already_processed:
            already_processed.add('httpsPort')
            try:
                self.httpsPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('keystoreFile', node)
        if value is not None and 'keystoreFile' not in already_processed:
            already_processed.add('keystoreFile')
            self.keystoreFile = value
        value = find_attr_value_('keystorePassword', node)
        if value is not None and 'keystorePassword' not in already_processed:
            already_processed.add('keystorePassword')
            self.keystorePassword = value
        value = find_attr_value_('maxQueue', node)
        if value is not None and 'maxQueue' not in already_processed:
            already_processed.add('maxQueue')
            try:
                self.maxQueue = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maxRequests', node)
        if value is not None and 'maxRequests' not in already_processed:
            already_processed.add('maxRequests')
            try:
                self.maxRequests = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('shutdownPort', node)
        if value is not None and 'shutdownPort' not in already_processed:
            already_processed.add('shutdownPort')
            try:
                self.shutdownPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sslProtocol', node)
        if value is not None and 'sslProtocol' not in already_processed:
            already_processed.add('sslProtocol')
            self.sslProtocol = value
        value = find_attr_value_('truststoreFile', node)
        if value is not None and 'truststoreFile' not in already_processed:
            already_processed.add('truststoreFile')
            self.truststoreFile = value
        value = find_attr_value_('truststorePassword', node)
        if value is not None and 'truststorePassword' not in already_processed:
            already_processed.add('truststorePassword')
            self.truststorePassword = value
        super(WebAppProcess, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WebAppProcess, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WebAppProcess


class Folder(DomainObj):
    subclass = None
    superclass = DomainObj
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, description=None):
        self.original_tagname_ = None
        super(Folder, self).__init__(id, idref, iid, annotations, name, description, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Folder)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Folder.subclass:
            return Folder.subclass(*args_, **kwargs_)
        else:
            return Folder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Folder, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='Folder', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Folder')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Folder')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='Folder', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='Folder'):
        super(Folder, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Folder')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='Folder', fromsubclass_=False, pretty_print=True):
        super(Folder, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Folder, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Folder, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Folder


class Grid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nodes=None):
        self.original_tagname_ = None
        self.nodes = _cast(None, nodes)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Grid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Grid.subclass:
            return Grid.subclass(*args_, **kwargs_)
        else:
            return Grid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nodes(self): return self.nodes
    def set_nodes(self, nodes): self.nodes = nodes
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='Grid', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Grid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Grid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='Grid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='Grid'):
        if self.nodes is not None and 'nodes' not in already_processed:
            already_processed.add('nodes')
            outfile.write(' nodes=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nodes), input_name='nodes')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='Grid', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nodes', node)
        if value is not None and 'nodes' not in already_processed:
            already_processed.add('nodes')
            self.nodes = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Grid, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Grid


class InstalledNodeResource(NodeResource):
    subclass = None
    superclass = NodeResource
    def __init__(self, vendorId=None, vendorName=None, version=None):
        self.original_tagname_ = None
        super(InstalledNodeResource, self).__init__()
        self.vendorId = _cast(int, vendorId)
        self.vendorName = _cast(None, vendorName)
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstalledNodeResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstalledNodeResource.subclass:
            return InstalledNodeResource.subclass(*args_, **kwargs_)
        else:
            return InstalledNodeResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendorId(self): return self.vendorId
    def set_vendorId(self, vendorId): self.vendorId = vendorId
    def get_vendorName(self): return self.vendorName
    def set_vendorName(self, vendorName): self.vendorName = vendorName
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            super(InstalledNodeResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='InstalledNodeResource', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstalledNodeResource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstalledNodeResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='InstalledNodeResource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='InstalledNodeResource'):
        super(InstalledNodeResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstalledNodeResource')
        if self.vendorId is not None and 'vendorId' not in already_processed:
            already_processed.add('vendorId')
            outfile.write(' vendorId="%s"' % self.gds_format_integer(self.vendorId, input_name='vendorId'))
        if self.vendorName is not None and 'vendorName' not in already_processed:
            already_processed.add('vendorName')
            outfile.write(' vendorName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendorName), input_name='vendorName')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='InstalledNodeResource', fromsubclass_=False, pretty_print=True):
        super(InstalledNodeResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendorId', node)
        if value is not None and 'vendorId' not in already_processed:
            already_processed.add('vendorId')
            try:
                self.vendorId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vendorName', node)
        if value is not None and 'vendorName' not in already_processed:
            already_processed.add('vendorName')
            self.vendorName = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        super(InstalledNodeResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InstalledNodeResource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InstalledNodeResource


class Node(DomainObj):
    subclass = None
    superclass = DomainObj
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, description=None, nodeOptions=None):
        self.original_tagname_ = None
        super(Node, self).__init__(id, idref, iid, annotations, name, description, )
        if nodeOptions is None:
            self.nodeOptions = []
        else:
            self.nodeOptions = nodeOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Node)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Node.subclass:
            return Node.subclass(*args_, **kwargs_)
        else:
            return Node(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nodeOptions(self): return self.nodeOptions
    def set_nodeOptions(self, nodeOptions): self.nodeOptions = nodeOptions
    def add_nodeOptions(self, value): self.nodeOptions.append(value)
    def insert_nodeOptions_at(self, index, value): self.nodeOptions.insert(index, value)
    def replace_nodeOptions_at(self, index, value): self.nodeOptions[index] = value
    def hasContent_(self):
        if (
            self.nodeOptions or
            super(Node, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='Node', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Node')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Node')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='Node', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='Node'):
        super(Node, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Node')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='Node', fromsubclass_=False, pretty_print=True):
        super(Node, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nodeOptions_ in self.nodeOptions:
            nodeOptions_.export(outfile, level, namespace_, name_='nodeOptions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Node, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nodeOptions':
            obj_ = nodeOptionsType.factory()
            obj_.build(child_)
            self.nodeOptions.append(obj_)
            obj_.original_tagname_ = 'nodeOptions'
        super(Node, self).buildChildren(child_, node, nodeName_, True)
# end class Node


class ResourceStringWithValue(ResourceString):
    subclass = None
    superclass = ResourceString
    def __init__(self, value=None):
        self.original_tagname_ = None
        super(ResourceStringWithValue, self).__init__()
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceStringWithValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceStringWithValue.subclass:
            return ResourceStringWithValue.subclass(*args_, **kwargs_)
        else:
            return ResourceStringWithValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            super(ResourceStringWithValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ResourceStringWithValue', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceStringWithValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceStringWithValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ResourceStringWithValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ResourceStringWithValue'):
        super(ResourceStringWithValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceStringWithValue')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ResourceStringWithValue', fromsubclass_=False, pretty_print=True):
        super(ResourceStringWithValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(ResourceStringWithValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResourceStringWithValue, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResourceStringWithValue


class Service(DomainObj):
    subclass = None
    superclass = DomainObj
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, description=None):
        self.original_tagname_ = None
        super(Service, self).__init__(id, idref, iid, annotations, name, description, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Service)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Service.subclass:
            return Service.subclass(*args_, **kwargs_)
        else:
            return Service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Service, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='Service', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Service')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='Service', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='Service'):
        super(Service, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Service')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='Service', fromsubclass_=False, pretty_print=True):
        super(Service, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Service, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Service, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Service


class ApplicationService(Service):
    """Model Change Log 2.8.0 abatra 4/21/2015 Added new contained property
    'computeNodeConfigurations' and 'serviceOptions'"""
    subclass = None
    superclass = Service
    def __init__(self, gridName=None, licenseName=None, serviceType=None, serviceVersion=None, computeNodeConfigurations=None, defaultComputeNodeOptions=None, internalServiceOptions=None, serviceOptions=None, serviceProcesses=None, serviceRefs=None):
        self.original_tagname_ = None
        super(ApplicationService, self).__init__()
        self.gridName = _cast(None, gridName)
        self.licenseName = _cast(None, licenseName)
        self.serviceType = _cast(None, serviceType)
        self.serviceVersion = _cast(None, serviceVersion)
        if computeNodeConfigurations is None:
            self.computeNodeConfigurations = []
        else:
            self.computeNodeConfigurations = computeNodeConfigurations
        if defaultComputeNodeOptions is None:
            self.defaultComputeNodeOptions = []
        else:
            self.defaultComputeNodeOptions = defaultComputeNodeOptions
        if internalServiceOptions is None:
            self.internalServiceOptions = []
        else:
            self.internalServiceOptions = internalServiceOptions
        if serviceOptions is None:
            self.serviceOptions = []
        else:
            self.serviceOptions = serviceOptions
        if serviceProcesses is None:
            self.serviceProcesses = []
        else:
            self.serviceProcesses = serviceProcesses
        if serviceRefs is None:
            self.serviceRefs = []
        else:
            self.serviceRefs = serviceRefs
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ApplicationService)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ApplicationService.subclass:
            return ApplicationService.subclass(*args_, **kwargs_)
        else:
            return ApplicationService(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_computeNodeConfigurations(self): return self.computeNodeConfigurations
    def set_computeNodeConfigurations(self, computeNodeConfigurations): self.computeNodeConfigurations = computeNodeConfigurations
    def add_computeNodeConfigurations(self, value): self.computeNodeConfigurations.append(value)
    def insert_computeNodeConfigurations_at(self, index, value): self.computeNodeConfigurations.insert(index, value)
    def replace_computeNodeConfigurations_at(self, index, value): self.computeNodeConfigurations[index] = value
    def get_defaultComputeNodeOptions(self): return self.defaultComputeNodeOptions
    def set_defaultComputeNodeOptions(self, defaultComputeNodeOptions): self.defaultComputeNodeOptions = defaultComputeNodeOptions
    def add_defaultComputeNodeOptions(self, value): self.defaultComputeNodeOptions.append(value)
    def insert_defaultComputeNodeOptions_at(self, index, value): self.defaultComputeNodeOptions.insert(index, value)
    def replace_defaultComputeNodeOptions_at(self, index, value): self.defaultComputeNodeOptions[index] = value
    def get_internalServiceOptions(self): return self.internalServiceOptions
    def set_internalServiceOptions(self, internalServiceOptions): self.internalServiceOptions = internalServiceOptions
    def add_internalServiceOptions(self, value): self.internalServiceOptions.append(value)
    def insert_internalServiceOptions_at(self, index, value): self.internalServiceOptions.insert(index, value)
    def replace_internalServiceOptions_at(self, index, value): self.internalServiceOptions[index] = value
    def get_serviceOptions(self): return self.serviceOptions
    def set_serviceOptions(self, serviceOptions): self.serviceOptions = serviceOptions
    def add_serviceOptions(self, value): self.serviceOptions.append(value)
    def insert_serviceOptions_at(self, index, value): self.serviceOptions.insert(index, value)
    def replace_serviceOptions_at(self, index, value): self.serviceOptions[index] = value
    def get_serviceProcesses(self): return self.serviceProcesses
    def set_serviceProcesses(self, serviceProcesses): self.serviceProcesses = serviceProcesses
    def add_serviceProcesses(self, value): self.serviceProcesses.append(value)
    def insert_serviceProcesses_at(self, index, value): self.serviceProcesses.insert(index, value)
    def replace_serviceProcesses_at(self, index, value): self.serviceProcesses[index] = value
    def get_serviceRefs(self): return self.serviceRefs
    def set_serviceRefs(self, serviceRefs): self.serviceRefs = serviceRefs
    def add_serviceRefs(self, value): self.serviceRefs.append(value)
    def insert_serviceRefs_at(self, index, value): self.serviceRefs.insert(index, value)
    def replace_serviceRefs_at(self, index, value): self.serviceRefs[index] = value
    def get_gridName(self): return self.gridName
    def set_gridName(self, gridName): self.gridName = gridName
    def get_licenseName(self): return self.licenseName
    def set_licenseName(self, licenseName): self.licenseName = licenseName
    def get_serviceType(self): return self.serviceType
    def set_serviceType(self, serviceType): self.serviceType = serviceType
    def get_serviceVersion(self): return self.serviceVersion
    def set_serviceVersion(self, serviceVersion): self.serviceVersion = serviceVersion
    def hasContent_(self):
        if (
            self.computeNodeConfigurations or
            self.defaultComputeNodeOptions or
            self.internalServiceOptions or
            self.serviceOptions or
            self.serviceProcesses or
            self.serviceRefs or
            super(ApplicationService, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ApplicationService', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ApplicationService')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApplicationService')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ApplicationService', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ApplicationService'):
        super(ApplicationService, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ApplicationService')
        if self.gridName is not None and 'gridName' not in already_processed:
            already_processed.add('gridName')
            outfile.write(' gridName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gridName), input_name='gridName')), ))
        if self.licenseName is not None and 'licenseName' not in already_processed:
            already_processed.add('licenseName')
            outfile.write(' licenseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.licenseName), input_name='licenseName')), ))
        if self.serviceType is not None and 'serviceType' not in already_processed:
            already_processed.add('serviceType')
            outfile.write(' serviceType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceType), input_name='serviceType')), ))
        if self.serviceVersion is not None and 'serviceVersion' not in already_processed:
            already_processed.add('serviceVersion')
            outfile.write(' serviceVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceVersion), input_name='serviceVersion')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ApplicationService', fromsubclass_=False, pretty_print=True):
        super(ApplicationService, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for computeNodeConfigurations_ in self.computeNodeConfigurations:
            computeNodeConfigurations_.export(outfile, level, namespace_, name_='computeNodeConfigurations', pretty_print=pretty_print)
        for defaultComputeNodeOptions_ in self.defaultComputeNodeOptions:
            defaultComputeNodeOptions_.export(outfile, level, namespace_, name_='defaultComputeNodeOptions', pretty_print=pretty_print)
        for internalServiceOptions_ in self.internalServiceOptions:
            internalServiceOptions_.export(outfile, level, namespace_, name_='internalServiceOptions', pretty_print=pretty_print)
        for serviceOptions_ in self.serviceOptions:
            serviceOptions_.export(outfile, level, namespace_, name_='serviceOptions', pretty_print=pretty_print)
        for serviceProcesses_ in self.serviceProcesses:
            serviceProcesses_.export(outfile, level, namespace_, name_='serviceProcesses', pretty_print=pretty_print)
        for serviceRefs_ in self.serviceRefs:
            serviceRefs_.export(outfile, level, namespace_, name_='serviceRefs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gridName', node)
        if value is not None and 'gridName' not in already_processed:
            already_processed.add('gridName')
            self.gridName = value
        value = find_attr_value_('licenseName', node)
        if value is not None and 'licenseName' not in already_processed:
            already_processed.add('licenseName')
            self.licenseName = value
        value = find_attr_value_('serviceType', node)
        if value is not None and 'serviceType' not in already_processed:
            already_processed.add('serviceType')
            self.serviceType = value
        value = find_attr_value_('serviceVersion', node)
        if value is not None and 'serviceVersion' not in already_processed:
            already_processed.add('serviceVersion')
            self.serviceVersion = value
        super(ApplicationService, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'computeNodeConfigurations':
            obj_ = computeNodeConfigurationsType.factory()
            obj_.build(child_)
            self.computeNodeConfigurations.append(obj_)
            obj_.original_tagname_ = 'computeNodeConfigurations'
        elif nodeName_ == 'defaultComputeNodeOptions':
            obj_ = defaultComputeNodeOptionsType.factory()
            obj_.build(child_)
            self.defaultComputeNodeOptions.append(obj_)
            obj_.original_tagname_ = 'defaultComputeNodeOptions'
        elif nodeName_ == 'internalServiceOptions':
            obj_ = internalServiceOptionsType.factory()
            obj_.build(child_)
            self.internalServiceOptions.append(obj_)
            obj_.original_tagname_ = 'internalServiceOptions'
        elif nodeName_ == 'serviceOptions':
            obj_ = serviceOptionsType.factory()
            obj_.build(child_)
            self.serviceOptions.append(obj_)
            obj_.original_tagname_ = 'serviceOptions'
        elif nodeName_ == 'serviceProcesses':
            obj_ = serviceProcessesType.factory()
            obj_.build(child_)
            self.serviceProcesses.append(obj_)
            obj_.original_tagname_ = 'serviceProcesses'
        elif nodeName_ == 'serviceRefs':
            obj_ = serviceRefsType.factory()
            obj_.build(child_)
            self.serviceRefs.append(obj_)
            obj_.original_tagname_ = 'serviceRefs'
        super(ApplicationService, self).buildChildren(child_, node, nodeName_, True)
# end class ApplicationService


class CoreService(Service):
    subclass = None
    superclass = Service
    def __init__(self):
        self.original_tagname_ = None
        super(CoreService, self).__init__()
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoreService)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoreService.subclass:
            return CoreService.subclass(*args_, **kwargs_)
        else:
            return CoreService(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CoreService, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='CoreService', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoreService')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoreService')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='CoreService', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='CoreService'):
        super(CoreService, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoreService')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='CoreService', fromsubclass_=False, pretty_print=True):
        super(CoreService, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CoreService, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CoreService, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CoreService


class DomainNode(Node):
    subclass = None
    superclass = Node
    def __init__(self, associated=None, portal=None, address=None, capabilities=None, options=None, predefineResources=None, resource=None, roles=None, user=None):
        self.original_tagname_ = None
        super(DomainNode, self).__init__()
        self.associated = _cast(bool, associated)
        self.portal = _cast(bool, portal)
        if address is None:
            self.address = []
        else:
            self.address = address
        if capabilities is None:
            self.capabilities = []
        else:
            self.capabilities = capabilities
        if options is None:
            self.options = []
        else:
            self.options = options
        if predefineResources is None:
            self.predefineResources = []
        else:
            self.predefineResources = predefineResources
        if resource is None:
            self.resource = []
        else:
            self.resource = resource
        if roles is None:
            self.roles = []
        else:
            self.roles = roles
        if user is None:
            self.user = []
        else:
            self.user = user
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomainNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomainNode.subclass:
            return DomainNode.subclass(*args_, **kwargs_)
        else:
            return DomainNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def add_address(self, value): self.address.append(value)
    def insert_address_at(self, index, value): self.address.insert(index, value)
    def replace_address_at(self, index, value): self.address[index] = value
    def get_capabilities(self): return self.capabilities
    def set_capabilities(self, capabilities): self.capabilities = capabilities
    def add_capabilities(self, value): self.capabilities.append(value)
    def insert_capabilities_at(self, index, value): self.capabilities.insert(index, value)
    def replace_capabilities_at(self, index, value): self.capabilities[index] = value
    def get_options(self): return self.options
    def set_options(self, options): self.options = options
    def add_options(self, value): self.options.append(value)
    def insert_options_at(self, index, value): self.options.insert(index, value)
    def replace_options_at(self, index, value): self.options[index] = value
    def get_predefineResources(self): return self.predefineResources
    def set_predefineResources(self, predefineResources): self.predefineResources = predefineResources
    def add_predefineResources(self, value): self.predefineResources.append(value)
    def insert_predefineResources_at(self, index, value): self.predefineResources.insert(index, value)
    def replace_predefineResources_at(self, index, value): self.predefineResources[index] = value
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def add_resource(self, value): self.resource.append(value)
    def insert_resource_at(self, index, value): self.resource.insert(index, value)
    def replace_resource_at(self, index, value): self.resource[index] = value
    def get_roles(self): return self.roles
    def set_roles(self, roles): self.roles = roles
    def add_roles(self, value): self.roles.append(value)
    def insert_roles_at(self, index, value): self.roles.insert(index, value)
    def replace_roles_at(self, index, value): self.roles[index] = value
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def add_user(self, value): self.user.append(value)
    def insert_user_at(self, index, value): self.user.insert(index, value)
    def replace_user_at(self, index, value): self.user[index] = value
    def get_associated(self): return self.associated
    def set_associated(self, associated): self.associated = associated
    def get_portal(self): return self.portal
    def set_portal(self, portal): self.portal = portal
    def hasContent_(self):
        if (
            self.address or
            self.capabilities or
            self.options or
            self.predefineResources or
            self.resource or
            self.roles or
            self.user or
            super(DomainNode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='DomainNode', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DomainNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='DomainNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='DomainNode'):
        super(DomainNode, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DomainNode')
        if self.associated is not None and 'associated' not in already_processed:
            already_processed.add('associated')
            outfile.write(' associated="%s"' % self.gds_format_boolean(self.associated, input_name='associated'))
        if self.portal is not None and 'portal' not in already_processed:
            already_processed.add('portal')
            outfile.write(' portal="%s"' % self.gds_format_boolean(self.portal, input_name='portal'))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='DomainNode', fromsubclass_=False, pretty_print=True):
        super(DomainNode, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for address_ in self.address:
            address_.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
        for capabilities_ in self.capabilities:
            capabilities_.export(outfile, level, namespace_, name_='capabilities', pretty_print=pretty_print)
        for options_ in self.options:
            options_.export(outfile, level, namespace_, name_='options', pretty_print=pretty_print)
        for predefineResources_ in self.predefineResources:
            predefineResources_.export(outfile, level, namespace_, name_='predefineResources', pretty_print=pretty_print)
        for resource_ in self.resource:
            resource_.export(outfile, level, namespace_, name_='resource', pretty_print=pretty_print)
        for roles_ in self.roles:
            roles_.export(outfile, level, namespace_, name_='roles', pretty_print=pretty_print)
        for user_ in self.user:
            user_.export(outfile, level, namespace_, name_='user', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('associated', node)
        if value is not None and 'associated' not in already_processed:
            already_processed.add('associated')
            if value in ('true', '1'):
                self.associated = True
            elif value in ('false', '0'):
                self.associated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('portal', node)
        if value is not None and 'portal' not in already_processed:
            already_processed.add('portal')
            if value in ('true', '1'):
                self.portal = True
            elif value in ('false', '0'):
                self.portal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(DomainNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            obj_ = NodeAddress.factory()
            obj_.build(child_)
            self.address.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'capabilities':
            obj_ = capabilitiesType.factory()
            obj_.build(child_)
            self.capabilities.append(obj_)
            obj_.original_tagname_ = 'capabilities'
        elif nodeName_ == 'options':
            obj_ = optionsType4.factory()
            obj_.build(child_)
            self.options.append(obj_)
            obj_.original_tagname_ = 'options'
        elif nodeName_ == 'predefineResources':
            obj_ = predefineResourcesType.factory()
            obj_.build(child_)
            self.predefineResources.append(obj_)
            obj_.original_tagname_ = 'predefineResources'
        elif nodeName_ == 'resource':
            obj_ = resourceType.factory()
            obj_.build(child_)
            self.resource.append(obj_)
            obj_.original_tagname_ = 'resource'
        elif nodeName_ == 'roles':
            obj_ = rolesType.factory()
            obj_.build(child_)
            self.roles.append(obj_)
            obj_.original_tagname_ = 'roles'
        elif nodeName_ == 'user':
            obj_ = UserRef.factory()
            obj_.build(child_)
            self.user.append(obj_)
            obj_.original_tagname_ = 'user'
        super(DomainNode, self).buildChildren(child_, node, nodeName_, True)
# end class DomainNode


class RemoteNode(Node):
    subclass = None
    superclass = Node
    def __init__(self):
        self.original_tagname_ = None
        super(RemoteNode, self).__init__()
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemoteNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemoteNode.subclass:
            return RemoteNode.subclass(*args_, **kwargs_)
        else:
            return RemoteNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RemoteNode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='RemoteNode', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RemoteNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemoteNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='RemoteNode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='RemoteNode'):
        super(RemoteNode, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RemoteNode')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='RemoteNode', fromsubclass_=False, pretty_print=True):
        super(RemoteNode, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RemoteNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RemoteNode, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RemoteNode


class linkedDomainsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinkedDomain=None):
        self.original_tagname_ = None
        if LinkedDomain is None:
            self.LinkedDomain = []
        else:
            self.LinkedDomain = LinkedDomain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkedDomainsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkedDomainsType.subclass:
            return linkedDomainsType.subclass(*args_, **kwargs_)
        else:
            return linkedDomainsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinkedDomain(self): return self.LinkedDomain
    def set_LinkedDomain(self, LinkedDomain): self.LinkedDomain = LinkedDomain
    def add_LinkedDomain(self, value): self.LinkedDomain.append(value)
    def insert_LinkedDomain_at(self, index, value): self.LinkedDomain.insert(index, value)
    def replace_LinkedDomain_at(self, index, value): self.LinkedDomain[index] = value
    def hasContent_(self):
        if (
            self.LinkedDomain
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='linkedDomainsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkedDomainsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linkedDomainsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='linkedDomainsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='linkedDomainsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='linkedDomainsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedDomain_ in self.LinkedDomain:
            LinkedDomain_.export(outfile, level, namespace_, name_='LinkedDomain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedDomain':
            obj_ = LinkedDomain.factory()
            obj_.build(child_)
            self.LinkedDomain.append(obj_)
            obj_.original_tagname_ = 'LinkedDomain'
# end class linkedDomainsType


class portalsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeRef=None):
        self.original_tagname_ = None
        if NodeRef is None:
            self.NodeRef = []
        else:
            self.NodeRef = NodeRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portalsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portalsType.subclass:
            return portalsType.subclass(*args_, **kwargs_)
        else:
            return portalsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeRef(self): return self.NodeRef
    def set_NodeRef(self, NodeRef): self.NodeRef = NodeRef
    def add_NodeRef(self, value): self.NodeRef.append(value)
    def insert_NodeRef_at(self, index, value): self.NodeRef.insert(index, value)
    def replace_NodeRef_at(self, index, value): self.NodeRef[index] = value
    def hasContent_(self):
        if (
            self.NodeRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='portalsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portalsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portalsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='portalsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='portalsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='portalsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeRef_ in self.NodeRef:
            NodeRef_.export(outfile, level, namespace_, name_='NodeRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeRef':
            obj_ = NodeRef.factory()
            obj_.build(child_)
            self.NodeRef.append(obj_)
            obj_.original_tagname_ = 'NodeRef'
# end class portalsType


class predefinedResourcesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeResource=None):
        self.original_tagname_ = None
        if NodeResource is None:
            self.NodeResource = []
        else:
            self.NodeResource = NodeResource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, predefinedResourcesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if predefinedResourcesType.subclass:
            return predefinedResourcesType.subclass(*args_, **kwargs_)
        else:
            return predefinedResourcesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeResource(self): return self.NodeResource
    def set_NodeResource(self, NodeResource): self.NodeResource = NodeResource
    def add_NodeResource(self, value): self.NodeResource.append(value)
    def insert_NodeResource_at(self, index, value): self.NodeResource.insert(index, value)
    def replace_NodeResource_at(self, index, value): self.NodeResource[index] = value
    def hasContent_(self):
        if (
            self.NodeResource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='predefinedResourcesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('predefinedResourcesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='predefinedResourcesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='predefinedResourcesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='predefinedResourcesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='predefinedResourcesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeResource_ in self.NodeResource:
            NodeResource_.export(outfile, level, namespace_, name_='NodeResource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeResource':
            class_obj_ = self.get_class_obj_(child_, NodeResource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NodeResource.append(obj_)
            obj_.original_tagname_ = 'NodeResource'
# end class predefinedResourcesType


class resourcesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeResource=None):
        self.original_tagname_ = None
        if NodeResource is None:
            self.NodeResource = []
        else:
            self.NodeResource = NodeResource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resourcesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resourcesType.subclass:
            return resourcesType.subclass(*args_, **kwargs_)
        else:
            return resourcesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeResource(self): return self.NodeResource
    def set_NodeResource(self, NodeResource): self.NodeResource = NodeResource
    def add_NodeResource(self, value): self.NodeResource.append(value)
    def insert_NodeResource_at(self, index, value): self.NodeResource.insert(index, value)
    def replace_NodeResource_at(self, index, value): self.NodeResource[index] = value
    def hasContent_(self):
        if (
            self.NodeResource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='resourcesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resourcesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resourcesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='resourcesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='resourcesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='resourcesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeResource_ in self.NodeResource:
            NodeResource_.export(outfile, level, namespace_, name_='NodeResource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeResource':
            class_obj_ = self.get_class_obj_(child_, NodeResource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NodeResource.append(obj_)
            obj_.original_tagname_ = 'NodeResource'
# end class resourcesType


class processStatesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceProcessStartupState=None):
        self.original_tagname_ = None
        if ServiceProcessStartupState is None:
            self.ServiceProcessStartupState = []
        else:
            self.ServiceProcessStartupState = ServiceProcessStartupState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processStatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processStatesType.subclass:
            return processStatesType.subclass(*args_, **kwargs_)
        else:
            return processStatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceProcessStartupState(self): return self.ServiceProcessStartupState
    def set_ServiceProcessStartupState(self, ServiceProcessStartupState): self.ServiceProcessStartupState = ServiceProcessStartupState
    def add_ServiceProcessStartupState(self, value): self.ServiceProcessStartupState.append(value)
    def insert_ServiceProcessStartupState_at(self, index, value): self.ServiceProcessStartupState.insert(index, value)
    def replace_ServiceProcessStartupState_at(self, index, value): self.ServiceProcessStartupState[index] = value
    def hasContent_(self):
        if (
            self.ServiceProcessStartupState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='processStatesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('processStatesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='processStatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='processStatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='processStatesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='processStatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ServiceProcessStartupState_ in self.ServiceProcessStartupState:
            ServiceProcessStartupState_.export(outfile, level, namespace_, name_='ServiceProcessStartupState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceProcessStartupState':
            obj_ = ServiceProcessStartupState.factory()
            obj_.build(child_)
            self.ServiceProcessStartupState.append(obj_)
            obj_.original_tagname_ = 'ServiceProcessStartupState'
# end class processStatesType


class serviceStatesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceStartupState=None):
        self.original_tagname_ = None
        if ServiceStartupState is None:
            self.ServiceStartupState = []
        else:
            self.ServiceStartupState = ServiceStartupState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceStatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceStatesType.subclass:
            return serviceStatesType.subclass(*args_, **kwargs_)
        else:
            return serviceStatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceStartupState(self): return self.ServiceStartupState
    def set_ServiceStartupState(self, ServiceStartupState): self.ServiceStartupState = ServiceStartupState
    def add_ServiceStartupState(self, value): self.ServiceStartupState.append(value)
    def insert_ServiceStartupState_at(self, index, value): self.ServiceStartupState.insert(index, value)
    def replace_ServiceStartupState_at(self, index, value): self.ServiceStartupState[index] = value
    def hasContent_(self):
        if (
            self.ServiceStartupState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='serviceStatesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceStatesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serviceStatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='serviceStatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='serviceStatesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='serviceStatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ServiceStartupState_ in self.ServiceStartupState:
            ServiceStartupState_.export(outfile, level, namespace_, name_='ServiceStartupState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceStartupState':
            obj_ = ServiceStartupState.factory()
            obj_.build(child_)
            self.ServiceStartupState.append(obj_)
            obj_.original_tagname_ = 'ServiceStartupState'
# end class serviceStatesType


class domainOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, domainOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if domainOptionsType.subclass:
            return domainOptionsType.subclass(*args_, **kwargs_)
        else:
            return domainOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='domainOptionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('domainOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='domainOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='domainOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='domainOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='domainOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class domainOptionsType


class configSettingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configSettingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configSettingsType.subclass:
            return configSettingsType.subclass(*args_, **kwargs_)
        else:
            return configSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='configSettingsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configSettingsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='configSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='configSettingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='configSettingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='configSettingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class configSettingsType


class gatewaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeAddress=None):
        self.original_tagname_ = None
        if NodeAddress is None:
            self.NodeAddress = []
        else:
            self.NodeAddress = NodeAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gatewaysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gatewaysType.subclass:
            return gatewaysType.subclass(*args_, **kwargs_)
        else:
            return gatewaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeAddress(self): return self.NodeAddress
    def set_NodeAddress(self, NodeAddress): self.NodeAddress = NodeAddress
    def add_NodeAddress(self, value): self.NodeAddress.append(value)
    def insert_NodeAddress_at(self, index, value): self.NodeAddress.insert(index, value)
    def replace_NodeAddress_at(self, index, value): self.NodeAddress[index] = value
    def hasContent_(self):
        if (
            self.NodeAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='gatewaysType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gatewaysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gatewaysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='gatewaysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='gatewaysType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='gatewaysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeAddress_ in self.NodeAddress:
            NodeAddress_.export(outfile, level, namespace_, name_='NodeAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeAddress':
            obj_ = NodeAddress.factory()
            obj_.build(child_)
            self.NodeAddress.append(obj_)
            obj_.original_tagname_ = 'NodeAddress'
# end class gatewaysType


class optionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Option=None):
        self.original_tagname_ = None
        if Option is None:
            self.Option = []
        else:
            self.Option = Option
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, optionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if optionsType.subclass:
            return optionsType.subclass(*args_, **kwargs_)
        else:
            return optionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Option(self): return self.Option
    def set_Option(self, Option): self.Option = Option
    def add_Option(self, value): self.Option.append(value)
    def insert_Option_at(self, index, value): self.Option.insert(index, value)
    def replace_Option_at(self, index, value): self.Option[index] = value
    def hasContent_(self):
        if (
            self.Option
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='optionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('optionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='optionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='optionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='optionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='optionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Option_ in self.Option:
            Option_.export(outfile, level, namespace_, name_='Option', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Option':
            class_obj_ = self.get_class_obj_(child_, Option)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Option.append(obj_)
            obj_.original_tagname_ = 'Option'
# end class optionsType


class optionsType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, optionsType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if optionsType1.subclass:
            return optionsType1.subclass(*args_, **kwargs_)
        else:
            return optionsType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='optionsType1', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('optionsType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='optionsType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='optionsType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='optionsType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='optionsType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class optionsType1


class folderObjectsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DomainObjectLocate=None):
        self.original_tagname_ = None
        if DomainObjectLocate is None:
            self.DomainObjectLocate = []
        else:
            self.DomainObjectLocate = DomainObjectLocate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, folderObjectsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if folderObjectsType.subclass:
            return folderObjectsType.subclass(*args_, **kwargs_)
        else:
            return folderObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DomainObjectLocate(self): return self.DomainObjectLocate
    def set_DomainObjectLocate(self, DomainObjectLocate): self.DomainObjectLocate = DomainObjectLocate
    def add_DomainObjectLocate(self, value): self.DomainObjectLocate.append(value)
    def insert_DomainObjectLocate_at(self, index, value): self.DomainObjectLocate.insert(index, value)
    def replace_DomainObjectLocate_at(self, index, value): self.DomainObjectLocate[index] = value
    def hasContent_(self):
        if (
            self.DomainObjectLocate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='folderObjectsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('folderObjectsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='folderObjectsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='folderObjectsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='folderObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='folderObjectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DomainObjectLocate_ in self.DomainObjectLocate:
            DomainObjectLocate_.export(outfile, level, namespace_, name_='DomainObjectLocate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DomainObjectLocate':
            obj_ = DomainObjectLocate.factory()
            obj_.build(child_)
            self.DomainObjectLocate.append(obj_)
            obj_.original_tagname_ = 'DomainObjectLocate'
# end class folderObjectsType


class resourcesType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResourceString=None):
        self.original_tagname_ = None
        if ResourceString is None:
            self.ResourceString = []
        else:
            self.ResourceString = ResourceString
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resourcesType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resourcesType2.subclass:
            return resourcesType2.subclass(*args_, **kwargs_)
        else:
            return resourcesType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResourceString(self): return self.ResourceString
    def set_ResourceString(self, ResourceString): self.ResourceString = ResourceString
    def add_ResourceString(self, value): self.ResourceString.append(value)
    def insert_ResourceString_at(self, index, value): self.ResourceString.insert(index, value)
    def replace_ResourceString_at(self, index, value): self.ResourceString[index] = value
    def hasContent_(self):
        if (
            self.ResourceString
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='resourcesType2', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resourcesType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resourcesType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='resourcesType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='resourcesType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='resourcesType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceString_ in self.ResourceString:
            ResourceString_.export(outfile, level, namespace_, name_='ResourceString', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResourceString':
            class_obj_ = self.get_class_obj_(child_, ResourceString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ResourceString.append(obj_)
            obj_.original_tagname_ = 'ResourceString'
# end class resourcesType2


class envVariablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Option=None):
        self.original_tagname_ = None
        if Option is None:
            self.Option = []
        else:
            self.Option = Option
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, envVariablesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if envVariablesType.subclass:
            return envVariablesType.subclass(*args_, **kwargs_)
        else:
            return envVariablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Option(self): return self.Option
    def set_Option(self, Option): self.Option = Option
    def add_Option(self, value): self.Option.append(value)
    def insert_Option_at(self, index, value): self.Option.insert(index, value)
    def replace_Option_at(self, index, value): self.Option[index] = value
    def hasContent_(self):
        if (
            self.Option
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='envVariablesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('envVariablesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='envVariablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='envVariablesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='envVariablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='envVariablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Option_ in self.Option:
            Option_.export(outfile, level, namespace_, name_='Option', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Option':
            class_obj_ = self.get_class_obj_(child_, Option)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Option.append(obj_)
            obj_.original_tagname_ = 'Option'
# end class envVariablesType


class internalProcessOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, internalProcessOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if internalProcessOptionsType.subclass:
            return internalProcessOptionsType.subclass(*args_, **kwargs_)
        else:
            return internalProcessOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='internalProcessOptionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('internalProcessOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='internalProcessOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='internalProcessOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='internalProcessOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='internalProcessOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class internalProcessOptionsType


class processOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, processOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if processOptionsType.subclass:
            return processOptionsType.subclass(*args_, **kwargs_)
        else:
            return processOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='processOptionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('processOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='processOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='processOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='processOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='processOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class processOptionsType


class optionsType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, optionsType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if optionsType3.subclass:
            return optionsType3.subclass(*args_, **kwargs_)
        else:
            return optionsType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='optionsType3', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('optionsType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='optionsType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='optionsType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='optionsType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='optionsType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class optionsType3


class nodeOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nodeOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nodeOptionsType.subclass:
            return nodeOptionsType.subclass(*args_, **kwargs_)
        else:
            return nodeOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='nodeOptionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nodeOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nodeOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='nodeOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='nodeOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='nodeOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class nodeOptionsType


class computeNodeConfigurationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ComputeNodeConfiguration=None):
        self.original_tagname_ = None
        if ComputeNodeConfiguration is None:
            self.ComputeNodeConfiguration = []
        else:
            self.ComputeNodeConfiguration = ComputeNodeConfiguration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, computeNodeConfigurationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if computeNodeConfigurationsType.subclass:
            return computeNodeConfigurationsType.subclass(*args_, **kwargs_)
        else:
            return computeNodeConfigurationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComputeNodeConfiguration(self): return self.ComputeNodeConfiguration
    def set_ComputeNodeConfiguration(self, ComputeNodeConfiguration): self.ComputeNodeConfiguration = ComputeNodeConfiguration
    def add_ComputeNodeConfiguration(self, value): self.ComputeNodeConfiguration.append(value)
    def insert_ComputeNodeConfiguration_at(self, index, value): self.ComputeNodeConfiguration.insert(index, value)
    def replace_ComputeNodeConfiguration_at(self, index, value): self.ComputeNodeConfiguration[index] = value
    def hasContent_(self):
        if (
            self.ComputeNodeConfiguration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='computeNodeConfigurationsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('computeNodeConfigurationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='computeNodeConfigurationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='computeNodeConfigurationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='computeNodeConfigurationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='computeNodeConfigurationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ComputeNodeConfiguration_ in self.ComputeNodeConfiguration:
            ComputeNodeConfiguration_.export(outfile, level, namespace_, name_='ComputeNodeConfiguration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComputeNodeConfiguration':
            obj_ = ComputeNodeConfiguration.factory()
            obj_.build(child_)
            self.ComputeNodeConfiguration.append(obj_)
            obj_.original_tagname_ = 'ComputeNodeConfiguration'
# end class computeNodeConfigurationsType


class defaultComputeNodeOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defaultComputeNodeOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defaultComputeNodeOptionsType.subclass:
            return defaultComputeNodeOptionsType.subclass(*args_, **kwargs_)
        else:
            return defaultComputeNodeOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='defaultComputeNodeOptionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defaultComputeNodeOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='defaultComputeNodeOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='defaultComputeNodeOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='defaultComputeNodeOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='defaultComputeNodeOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class defaultComputeNodeOptionsType


class internalServiceOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, internalServiceOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if internalServiceOptionsType.subclass:
            return internalServiceOptionsType.subclass(*args_, **kwargs_)
        else:
            return internalServiceOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='internalServiceOptionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('internalServiceOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='internalServiceOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='internalServiceOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='internalServiceOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='internalServiceOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class internalServiceOptionsType


class serviceOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceOptionsType.subclass:
            return serviceOptionsType.subclass(*args_, **kwargs_)
        else:
            return serviceOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='serviceOptionsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serviceOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='serviceOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='serviceOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='serviceOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class serviceOptionsType


class serviceProcessesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Process=None):
        self.original_tagname_ = None
        if Process is None:
            self.Process = []
        else:
            self.Process = Process
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceProcessesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceProcessesType.subclass:
            return serviceProcessesType.subclass(*args_, **kwargs_)
        else:
            return serviceProcessesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Process(self): return self.Process
    def set_Process(self, Process): self.Process = Process
    def add_Process(self, value): self.Process.append(value)
    def insert_Process_at(self, index, value): self.Process.insert(index, value)
    def replace_Process_at(self, index, value): self.Process[index] = value
    def hasContent_(self):
        if (
            self.Process
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='serviceProcessesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceProcessesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serviceProcessesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='serviceProcessesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='serviceProcessesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='serviceProcessesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Process_ in self.Process:
            Process_.export(outfile, level, namespace_, name_='Process', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Process':
            class_obj_ = self.get_class_obj_(child_, Process)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Process.append(obj_)
            obj_.original_tagname_ = 'Process'
# end class serviceProcessesType


class serviceRefsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceRef=None):
        self.original_tagname_ = None
        if ServiceRef is None:
            self.ServiceRef = []
        else:
            self.ServiceRef = ServiceRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceRefsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceRefsType.subclass:
            return serviceRefsType.subclass(*args_, **kwargs_)
        else:
            return serviceRefsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceRef(self): return self.ServiceRef
    def set_ServiceRef(self, ServiceRef): self.ServiceRef = ServiceRef
    def add_ServiceRef(self, value): self.ServiceRef.append(value)
    def insert_ServiceRef_at(self, index, value): self.ServiceRef.insert(index, value)
    def replace_ServiceRef_at(self, index, value): self.ServiceRef[index] = value
    def hasContent_(self):
        if (
            self.ServiceRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='serviceRefsType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceRefsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serviceRefsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='serviceRefsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='serviceRefsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='serviceRefsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ServiceRef_ in self.ServiceRef:
            ServiceRef_.export(outfile, level, namespace_, name_='ServiceRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceRef':
            obj_ = ServiceRef.factory()
            obj_.build(child_)
            self.ServiceRef.append(obj_)
            obj_.original_tagname_ = 'ServiceRef'
# end class serviceRefsType


class capabilitiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeCapability=None):
        self.original_tagname_ = None
        if NodeCapability is None:
            self.NodeCapability = []
        else:
            self.NodeCapability = NodeCapability
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, capabilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if capabilitiesType.subclass:
            return capabilitiesType.subclass(*args_, **kwargs_)
        else:
            return capabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeCapability(self): return self.NodeCapability
    def set_NodeCapability(self, NodeCapability): self.NodeCapability = NodeCapability
    def add_NodeCapability(self, value): self.NodeCapability.append(value)
    def insert_NodeCapability_at(self, index, value): self.NodeCapability.insert(index, value)
    def replace_NodeCapability_at(self, index, value): self.NodeCapability[index] = value
    def hasContent_(self):
        if (
            self.NodeCapability
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='capabilitiesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('capabilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='capabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='capabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='capabilitiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='capabilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeCapability_ in self.NodeCapability:
            NodeCapability_.export(outfile, level, namespace_, name_='NodeCapability', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeCapability':
            obj_ = NodeCapability.factory()
            obj_.build(child_)
            self.NodeCapability.append(obj_)
            obj_.original_tagname_ = 'NodeCapability'
# end class capabilitiesType


class optionsType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionGroup=None):
        self.original_tagname_ = None
        if OptionGroup is None:
            self.OptionGroup = []
        else:
            self.OptionGroup = OptionGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, optionsType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if optionsType4.subclass:
            return optionsType4.subclass(*args_, **kwargs_)
        else:
            return optionsType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionGroup(self): return self.OptionGroup
    def set_OptionGroup(self, OptionGroup): self.OptionGroup = OptionGroup
    def add_OptionGroup(self, value): self.OptionGroup.append(value)
    def insert_OptionGroup_at(self, index, value): self.OptionGroup.insert(index, value)
    def replace_OptionGroup_at(self, index, value): self.OptionGroup[index] = value
    def hasContent_(self):
        if (
            self.OptionGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='optionsType4', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:mgt="http://com.informatica.isp.metadata.mgt/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('optionsType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='optionsType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='optionsType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='optionsType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='optionsType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OptionGroup_ in self.OptionGroup:
            OptionGroup_.export(outfile, level, namespace_, name_='OptionGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionGroup':
            obj_ = OptionGroup.factory()
            obj_.build(child_)
            self.OptionGroup.append(obj_)
            obj_.original_tagname_ = 'OptionGroup'
# end class optionsType4


class predefineResourcesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeResource=None):
        self.original_tagname_ = None
        if NodeResource is None:
            self.NodeResource = []
        else:
            self.NodeResource = NodeResource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, predefineResourcesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if predefineResourcesType.subclass:
            return predefineResourcesType.subclass(*args_, **kwargs_)
        else:
            return predefineResourcesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeResource(self): return self.NodeResource
    def set_NodeResource(self, NodeResource): self.NodeResource = NodeResource
    def add_NodeResource(self, value): self.NodeResource.append(value)
    def insert_NodeResource_at(self, index, value): self.NodeResource.insert(index, value)
    def replace_NodeResource_at(self, index, value): self.NodeResource[index] = value
    def hasContent_(self):
        if (
            self.NodeResource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='predefineResourcesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('predefineResourcesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='predefineResourcesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='predefineResourcesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='predefineResourcesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='predefineResourcesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeResource_ in self.NodeResource:
            NodeResource_.export(outfile, level, namespace_, name_='NodeResource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeResource':
            class_obj_ = self.get_class_obj_(child_, NodeResource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NodeResource.append(obj_)
            obj_.original_tagname_ = 'NodeResource'
# end class predefineResourcesType


class resourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeResource=None):
        self.original_tagname_ = None
        if NodeResource is None:
            self.NodeResource = []
        else:
            self.NodeResource = NodeResource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resourceType.subclass:
            return resourceType.subclass(*args_, **kwargs_)
        else:
            return resourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeResource(self): return self.NodeResource
    def set_NodeResource(self, NodeResource): self.NodeResource = NodeResource
    def add_NodeResource(self, value): self.NodeResource.append(value)
    def insert_NodeResource_at(self, index, value): self.NodeResource.insert(index, value)
    def replace_NodeResource_at(self, index, value): self.NodeResource[index] = value
    def hasContent_(self):
        if (
            self.NodeResource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='resourceType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resourceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='resourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='resourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='resourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeResource_ in self.NodeResource:
            NodeResource_.export(outfile, level, namespace_, name_='NodeResource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeResource':
            class_obj_ = self.get_class_obj_(child_, NodeResource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NodeResource.append(obj_)
            obj_.original_tagname_ = 'NodeResource'
# end class resourceType


class rolesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RoleTypeContainer=None):
        self.original_tagname_ = None
        if RoleTypeContainer is None:
            self.RoleTypeContainer = []
        else:
            self.RoleTypeContainer = RoleTypeContainer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rolesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rolesType.subclass:
            return rolesType.subclass(*args_, **kwargs_)
        else:
            return rolesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RoleTypeContainer(self): return self.RoleTypeContainer
    def set_RoleTypeContainer(self, RoleTypeContainer): self.RoleTypeContainer = RoleTypeContainer
    def add_RoleTypeContainer(self, value): self.RoleTypeContainer.append(value)
    def insert_RoleTypeContainer_at(self, index, value): self.RoleTypeContainer.insert(index, value)
    def replace_RoleTypeContainer_at(self, index, value): self.RoleTypeContainer[index] = value
    def hasContent_(self):
        if (
            self.RoleTypeContainer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='rolesType', namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2" xmlns:domainconfigurationservice="http://com.informatica.isp.metadata.domainconfigurationservice/2" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rolesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rolesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='rolesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='rolesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='rolesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RoleTypeContainer_ in self.RoleTypeContainer:
            RoleTypeContainer_.export(outfile, level, namespace_, name_='RoleTypeContainer', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RoleTypeContainer':
            obj_ = RoleTypeContainer.factory()
            obj_.build(child_)
            self.RoleTypeContainer.append(obj_)
            obj_.original_tagname_ = 'RoleTypeContainer'
# end class rolesType


class LinkedDomain(DomainObj):
    subclass = None
    superclass = DomainObj
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, description=None, gateways=None):
        self.original_tagname_ = None
        super(LinkedDomain, self).__init__(id, idref, iid, annotations, name, description, )
        if gateways is None:
            self.gateways = []
        else:
            self.gateways = gateways
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedDomain.subclass:
            return LinkedDomain.subclass(*args_, **kwargs_)
        else:
            return LinkedDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gateways(self): return self.gateways
    def set_gateways(self, gateways): self.gateways = gateways
    def add_gateways(self, value): self.gateways.append(value)
    def insert_gateways_at(self, index, value): self.gateways.insert(index, value)
    def replace_gateways_at(self, index, value): self.gateways[index] = value
    def hasContent_(self):
        if (
            self.gateways or
            super(LinkedDomain, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='LinkedDomain', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinkedDomain')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedDomain')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='LinkedDomain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='LinkedDomain'):
        super(LinkedDomain, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedDomain')
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='LinkedDomain', fromsubclass_=False, pretty_print=True):
        super(LinkedDomain, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gateways_ in self.gateways:
            gateways_.export(outfile, level, namespace_, name_='gateways', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LinkedDomain, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gateways':
            obj_ = gatewaysType.factory()
            obj_.build(child_)
            self.gateways.append(obj_)
            obj_.original_tagname_ = 'gateways'
        super(LinkedDomain, self).buildChildren(child_, node, nodeName_, True)
# end class LinkedDomain


class DomainServiceConfig(ISPNamedObject):
    """Model Change Log 2.9.0 dchhatan 19/8/2013 For property description:
    Changed the persistence size to LengthTypeMax.UNBOUNDED Changed
    Length to LengthType.UNBOUNDED To support unbounded length of
    description 2.15.0 dchhatan 10/4/2015 Added new property {@code
    builtinServiceFolderName} for storing folder name of singleton
    services"""
    subclass = None
    superclass = ISPNamedObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, builtinServiceFolderName=None, domainDescription=None, domainOptions=None):
        self.original_tagname_ = None
        super(DomainServiceConfig, self).__init__(id, idref, iid, annotations, name, )
        self.builtinServiceFolderName = _cast(None, builtinServiceFolderName)
        self.domainDescription = _cast(None, domainDescription)
        if domainOptions is None:
            self.domainOptions = []
        else:
            self.domainOptions = domainOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomainServiceConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomainServiceConfig.subclass:
            return DomainServiceConfig.subclass(*args_, **kwargs_)
        else:
            return DomainServiceConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainOptions(self): return self.domainOptions
    def set_domainOptions(self, domainOptions): self.domainOptions = domainOptions
    def add_domainOptions(self, value): self.domainOptions.append(value)
    def insert_domainOptions_at(self, index, value): self.domainOptions.insert(index, value)
    def replace_domainOptions_at(self, index, value): self.domainOptions[index] = value
    def get_builtinServiceFolderName(self): return self.builtinServiceFolderName
    def set_builtinServiceFolderName(self, builtinServiceFolderName): self.builtinServiceFolderName = builtinServiceFolderName
    def get_domainDescription(self): return self.domainDescription
    def set_domainDescription(self, domainDescription): self.domainDescription = domainDescription
    def hasContent_(self):
        if (
            self.domainOptions or
            super(DomainServiceConfig, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='DomainServiceConfig', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DomainServiceConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainServiceConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='DomainServiceConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='DomainServiceConfig'):
        super(DomainServiceConfig, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DomainServiceConfig')
        if self.builtinServiceFolderName is not None and 'builtinServiceFolderName' not in already_processed:
            already_processed.add('builtinServiceFolderName')
            outfile.write(' builtinServiceFolderName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.builtinServiceFolderName), input_name='builtinServiceFolderName')), ))
        if self.domainDescription is not None and 'domainDescription' not in already_processed:
            already_processed.add('domainDescription')
            outfile.write(' domainDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.domainDescription), input_name='domainDescription')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='DomainServiceConfig', fromsubclass_=False, pretty_print=True):
        super(DomainServiceConfig, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for domainOptions_ in self.domainOptions:
            domainOptions_.export(outfile, level, namespace_, name_='domainOptions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('builtinServiceFolderName', node)
        if value is not None and 'builtinServiceFolderName' not in already_processed:
            already_processed.add('builtinServiceFolderName')
            self.builtinServiceFolderName = value
        value = find_attr_value_('domainDescription', node)
        if value is not None and 'domainDescription' not in already_processed:
            already_processed.add('domainDescription')
            self.domainDescription = value
        super(DomainServiceConfig, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainOptions':
            obj_ = domainOptionsType.factory()
            obj_.build(child_)
            self.domainOptions.append(obj_)
            obj_.original_tagname_ = 'domainOptions'
        super(DomainServiceConfig, self).buildChildren(child_, node, nodeName_, True)
# end class DomainServiceConfig


class StoredStartupState(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, processStates=None, serviceStates=None):
        self.original_tagname_ = None
        super(StoredStartupState, self).__init__(id, idref, iid, annotations, )
        self.name = _cast(None, name)
        if processStates is None:
            self.processStates = []
        else:
            self.processStates = processStates
        if serviceStates is None:
            self.serviceStates = []
        else:
            self.serviceStates = serviceStates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StoredStartupState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StoredStartupState.subclass:
            return StoredStartupState.subclass(*args_, **kwargs_)
        else:
            return StoredStartupState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processStates(self): return self.processStates
    def set_processStates(self, processStates): self.processStates = processStates
    def add_processStates(self, value): self.processStates.append(value)
    def insert_processStates_at(self, index, value): self.processStates.insert(index, value)
    def replace_processStates_at(self, index, value): self.processStates[index] = value
    def get_serviceStates(self): return self.serviceStates
    def set_serviceStates(self, serviceStates): self.serviceStates = serviceStates
    def add_serviceStates(self, value): self.serviceStates.append(value)
    def insert_serviceStates_at(self, index, value): self.serviceStates.insert(index, value)
    def replace_serviceStates_at(self, index, value): self.serviceStates[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.processStates or
            self.serviceStates or
            super(StoredStartupState, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='StoredStartupState', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StoredStartupState')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StoredStartupState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='StoredStartupState', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='StoredStartupState'):
        super(StoredStartupState, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StoredStartupState')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='StoredStartupState', fromsubclass_=False, pretty_print=True):
        super(StoredStartupState, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for processStates_ in self.processStates:
            processStates_.export(outfile, level, namespace_, name_='processStates', pretty_print=pretty_print)
        for serviceStates_ in self.serviceStates:
            serviceStates_.export(outfile, level, namespace_, name_='serviceStates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(StoredStartupState, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processStates':
            obj_ = processStatesType.factory()
            obj_.build(child_)
            self.processStates.append(obj_)
            obj_.original_tagname_ = 'processStates'
        elif nodeName_ == 'serviceStates':
            obj_ = serviceStatesType.factory()
            obj_.build(child_)
            self.serviceStates.append(obj_)
            obj_.original_tagname_ = 'serviceStates'
        super(StoredStartupState, self).buildChildren(child_, node, nodeName_, True)
# end class StoredStartupState


class ServiceRuntime(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, state=None, service=None):
        self.original_tagname_ = None
        super(ServiceRuntime, self).__init__(id, idref, iid, annotations, )
        self.state = _cast(None, state)
        if service is None:
            self.service = []
        else:
            self.service = service
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRuntime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRuntime.subclass:
            return ServiceRuntime.subclass(*args_, **kwargs_)
        else:
            return ServiceRuntime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def add_service(self, value): self.service.append(value)
    def insert_service_at(self, index, value): self.service.insert(index, value)
    def replace_service_at(self, index, value): self.service[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def hasContent_(self):
        if (
            self.service or
            super(ServiceRuntime, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ServiceRuntime', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRuntime')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceRuntime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ServiceRuntime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ServiceRuntime'):
        super(ServiceRuntime, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceRuntime')
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (quote_attrib(self.state), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ServiceRuntime', fromsubclass_=False, pretty_print=True):
        super(ServiceRuntime, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for service_ in self.service:
            service_.export(outfile, level, namespace_, name_='service', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        super(ServiceRuntime, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'service':
            obj_ = ServiceRef.factory()
            obj_.build(child_)
            self.service.append(obj_)
            obj_.original_tagname_ = 'service'
        super(ServiceRuntime, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceRuntime


class ProcessRuntime(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, nodeName=None, pid=None, port=None, primary=None, serviceName=None, serviceURL=None, state=None):
        self.original_tagname_ = None
        super(ProcessRuntime, self).__init__(id, idref, iid, annotations, )
        self.nodeName = _cast(None, nodeName)
        self.pid = _cast(int, pid)
        self.port = _cast(int, port)
        self.primary = _cast(bool, primary)
        self.serviceName = _cast(None, serviceName)
        self.serviceURL = _cast(None, serviceURL)
        self.state = _cast(None, state)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessRuntime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessRuntime.subclass:
            return ProcessRuntime.subclass(*args_, **kwargs_)
        else:
            return ProcessRuntime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nodeName(self): return self.nodeName
    def set_nodeName(self, nodeName): self.nodeName = nodeName
    def get_pid(self): return self.pid
    def set_pid(self, pid): self.pid = pid
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_primary(self): return self.primary
    def set_primary(self, primary): self.primary = primary
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_serviceURL(self): return self.serviceURL
    def set_serviceURL(self, serviceURL): self.serviceURL = serviceURL
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def hasContent_(self):
        if (
            super(ProcessRuntime, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='ProcessRuntime', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessRuntime')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessRuntime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='ProcessRuntime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='ProcessRuntime'):
        super(ProcessRuntime, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessRuntime')
        if self.nodeName is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            outfile.write(' nodeName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nodeName), input_name='nodeName')), ))
        if self.pid is not None and 'pid' not in already_processed:
            already_processed.add('pid')
            outfile.write(' pid="%s"' % self.gds_format_integer(self.pid, input_name='pid'))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
        if self.primary is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary="%s"' % self.gds_format_boolean(self.primary, input_name='primary'))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceName), input_name='serviceName')), ))
        if self.serviceURL is not None and 'serviceURL' not in already_processed:
            already_processed.add('serviceURL')
            outfile.write(' serviceURL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceURL), input_name='serviceURL')), ))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='ProcessRuntime', fromsubclass_=False, pretty_print=True):
        super(ProcessRuntime, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nodeName', node)
        if value is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            self.nodeName = value
        value = find_attr_value_('pid', node)
        if value is not None and 'pid' not in already_processed:
            already_processed.add('pid')
            try:
                self.pid = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            try:
                self.port = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            if value in ('true', '1'):
                self.primary = True
            elif value in ('false', '0'):
                self.primary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('serviceURL', node)
        if value is not None and 'serviceURL' not in already_processed:
            already_processed.add('serviceURL')
            self.serviceURL = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        super(ProcessRuntime, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProcessRuntime, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProcessRuntime


class NodeConfig(ISPObject):
    """Model Change Log 2.11.0 sumittal 10/09/2013 Changed the property
    size of logServiceDir from LengthTypeMax.DEFAULT_PERSISTENCE to
    LengthTypeMax.UNBOUNDED 2.17.0 vmehta 1/6/2017 Adding
    EarlierInfaHomeConfig in NodeConfig"""
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, adminconsolePort=None, adminconsoleShutdownPort=None, domainName=None, logServiceDir=None, nodeName=None, options=None, resetHostPort=None, systemLogDir=None, tlsEnabled=None, address=None, earlierInfaHomeConfig=None, httpsInfo=None, portals=None, predefinedResources=None, resources=None, securityConfig=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NodeConfig, self).__init__(id, idref, iid, annotations, extensiontype_, )
        self.adminconsolePort = _cast(int, adminconsolePort)
        self.adminconsoleShutdownPort = _cast(int, adminconsoleShutdownPort)
        self.domainName = _cast(None, domainName)
        self.logServiceDir = _cast(None, logServiceDir)
        self.nodeName = _cast(None, nodeName)
        self.options = _cast(None, options)
        self.resetHostPort = _cast(bool, resetHostPort)
        self.systemLogDir = _cast(None, systemLogDir)
        self.tlsEnabled = _cast(bool, tlsEnabled)
        if address is None:
            self.address = []
        else:
            self.address = address
        if earlierInfaHomeConfig is None:
            self.earlierInfaHomeConfig = []
        else:
            self.earlierInfaHomeConfig = earlierInfaHomeConfig
        if httpsInfo is None:
            self.httpsInfo = []
        else:
            self.httpsInfo = httpsInfo
        if portals is None:
            self.portals = []
        else:
            self.portals = portals
        if predefinedResources is None:
            self.predefinedResources = []
        else:
            self.predefinedResources = predefinedResources
        if resources is None:
            self.resources = []
        else:
            self.resources = resources
        if securityConfig is None:
            self.securityConfig = []
        else:
            self.securityConfig = securityConfig
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NodeConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NodeConfig.subclass:
            return NodeConfig.subclass(*args_, **kwargs_)
        else:
            return NodeConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def add_address(self, value): self.address.append(value)
    def insert_address_at(self, index, value): self.address.insert(index, value)
    def replace_address_at(self, index, value): self.address[index] = value
    def get_earlierInfaHomeConfig(self): return self.earlierInfaHomeConfig
    def set_earlierInfaHomeConfig(self, earlierInfaHomeConfig): self.earlierInfaHomeConfig = earlierInfaHomeConfig
    def add_earlierInfaHomeConfig(self, value): self.earlierInfaHomeConfig.append(value)
    def insert_earlierInfaHomeConfig_at(self, index, value): self.earlierInfaHomeConfig.insert(index, value)
    def replace_earlierInfaHomeConfig_at(self, index, value): self.earlierInfaHomeConfig[index] = value
    def get_httpsInfo(self): return self.httpsInfo
    def set_httpsInfo(self, httpsInfo): self.httpsInfo = httpsInfo
    def add_httpsInfo(self, value): self.httpsInfo.append(value)
    def insert_httpsInfo_at(self, index, value): self.httpsInfo.insert(index, value)
    def replace_httpsInfo_at(self, index, value): self.httpsInfo[index] = value
    def get_portals(self): return self.portals
    def set_portals(self, portals): self.portals = portals
    def add_portals(self, value): self.portals.append(value)
    def insert_portals_at(self, index, value): self.portals.insert(index, value)
    def replace_portals_at(self, index, value): self.portals[index] = value
    def get_predefinedResources(self): return self.predefinedResources
    def set_predefinedResources(self, predefinedResources): self.predefinedResources = predefinedResources
    def add_predefinedResources(self, value): self.predefinedResources.append(value)
    def insert_predefinedResources_at(self, index, value): self.predefinedResources.insert(index, value)
    def replace_predefinedResources_at(self, index, value): self.predefinedResources[index] = value
    def get_resources(self): return self.resources
    def set_resources(self, resources): self.resources = resources
    def add_resources(self, value): self.resources.append(value)
    def insert_resources_at(self, index, value): self.resources.insert(index, value)
    def replace_resources_at(self, index, value): self.resources[index] = value
    def get_securityConfig(self): return self.securityConfig
    def set_securityConfig(self, securityConfig): self.securityConfig = securityConfig
    def add_securityConfig(self, value): self.securityConfig.append(value)
    def insert_securityConfig_at(self, index, value): self.securityConfig.insert(index, value)
    def replace_securityConfig_at(self, index, value): self.securityConfig[index] = value
    def get_adminconsolePort(self): return self.adminconsolePort
    def set_adminconsolePort(self, adminconsolePort): self.adminconsolePort = adminconsolePort
    def get_adminconsoleShutdownPort(self): return self.adminconsoleShutdownPort
    def set_adminconsoleShutdownPort(self, adminconsoleShutdownPort): self.adminconsoleShutdownPort = adminconsoleShutdownPort
    def get_domainName(self): return self.domainName
    def set_domainName(self, domainName): self.domainName = domainName
    def get_logServiceDir(self): return self.logServiceDir
    def set_logServiceDir(self, logServiceDir): self.logServiceDir = logServiceDir
    def get_nodeName(self): return self.nodeName
    def set_nodeName(self, nodeName): self.nodeName = nodeName
    def get_options(self): return self.options
    def set_options(self, options): self.options = options
    def get_resetHostPort(self): return self.resetHostPort
    def set_resetHostPort(self, resetHostPort): self.resetHostPort = resetHostPort
    def get_systemLogDir(self): return self.systemLogDir
    def set_systemLogDir(self, systemLogDir): self.systemLogDir = systemLogDir
    def get_tlsEnabled(self): return self.tlsEnabled
    def set_tlsEnabled(self, tlsEnabled): self.tlsEnabled = tlsEnabled
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.address or
            self.earlierInfaHomeConfig or
            self.httpsInfo or
            self.portals or
            self.predefinedResources or
            self.resources or
            self.securityConfig or
            super(NodeConfig, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='NodeConfig', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NodeConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='NodeConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='NodeConfig'):
        super(NodeConfig, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NodeConfig')
        if self.adminconsolePort is not None and 'adminconsolePort' not in already_processed:
            already_processed.add('adminconsolePort')
            outfile.write(' adminconsolePort="%s"' % self.gds_format_integer(self.adminconsolePort, input_name='adminconsolePort'))
        if self.adminconsoleShutdownPort is not None and 'adminconsoleShutdownPort' not in already_processed:
            already_processed.add('adminconsoleShutdownPort')
            outfile.write(' adminconsoleShutdownPort="%s"' % self.gds_format_integer(self.adminconsoleShutdownPort, input_name='adminconsoleShutdownPort'))
        if self.domainName is not None and 'domainName' not in already_processed:
            already_processed.add('domainName')
            outfile.write(' domainName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.domainName), input_name='domainName')), ))
        if self.logServiceDir is not None and 'logServiceDir' not in already_processed:
            already_processed.add('logServiceDir')
            outfile.write(' logServiceDir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.logServiceDir), input_name='logServiceDir')), ))
        if self.nodeName is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            outfile.write(' nodeName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nodeName), input_name='nodeName')), ))
        if self.options is not None and 'options' not in already_processed:
            already_processed.add('options')
            outfile.write(' options=%s' % (quote_attrib(self.options), ))
        if self.resetHostPort is not None and 'resetHostPort' not in already_processed:
            already_processed.add('resetHostPort')
            outfile.write(' resetHostPort="%s"' % self.gds_format_boolean(self.resetHostPort, input_name='resetHostPort'))
        if self.systemLogDir is not None and 'systemLogDir' not in already_processed:
            already_processed.add('systemLogDir')
            outfile.write(' systemLogDir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.systemLogDir), input_name='systemLogDir')), ))
        if self.tlsEnabled is not None and 'tlsEnabled' not in already_processed:
            already_processed.add('tlsEnabled')
            outfile.write(' tlsEnabled="%s"' % self.gds_format_boolean(self.tlsEnabled, input_name='tlsEnabled'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='NodeConfig', fromsubclass_=False, pretty_print=True):
        super(NodeConfig, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for address_ in self.address:
            address_.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
        for earlierInfaHomeConfig_ in self.earlierInfaHomeConfig:
            earlierInfaHomeConfig_.export(outfile, level, namespace_, name_='earlierInfaHomeConfig', pretty_print=pretty_print)
        for httpsInfo_ in self.httpsInfo:
            httpsInfo_.export(outfile, level, namespace_, name_='httpsInfo', pretty_print=pretty_print)
        for portals_ in self.portals:
            portals_.export(outfile, level, namespace_, name_='portals', pretty_print=pretty_print)
        for predefinedResources_ in self.predefinedResources:
            predefinedResources_.export(outfile, level, namespace_, name_='predefinedResources', pretty_print=pretty_print)
        for resources_ in self.resources:
            resources_.export(outfile, level, namespace_, name_='resources', pretty_print=pretty_print)
        for securityConfig_ in self.securityConfig:
            securityConfig_.export(outfile, level, namespace_, name_='securityConfig', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('adminconsolePort', node)
        if value is not None and 'adminconsolePort' not in already_processed:
            already_processed.add('adminconsolePort')
            try:
                self.adminconsolePort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('adminconsoleShutdownPort', node)
        if value is not None and 'adminconsoleShutdownPort' not in already_processed:
            already_processed.add('adminconsoleShutdownPort')
            try:
                self.adminconsoleShutdownPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('domainName', node)
        if value is not None and 'domainName' not in already_processed:
            already_processed.add('domainName')
            self.domainName = value
        value = find_attr_value_('logServiceDir', node)
        if value is not None and 'logServiceDir' not in already_processed:
            already_processed.add('logServiceDir')
            self.logServiceDir = value
        value = find_attr_value_('nodeName', node)
        if value is not None and 'nodeName' not in already_processed:
            already_processed.add('nodeName')
            self.nodeName = value
        value = find_attr_value_('options', node)
        if value is not None and 'options' not in already_processed:
            already_processed.add('options')
            self.options = value
        value = find_attr_value_('resetHostPort', node)
        if value is not None and 'resetHostPort' not in already_processed:
            already_processed.add('resetHostPort')
            if value in ('true', '1'):
                self.resetHostPort = True
            elif value in ('false', '0'):
                self.resetHostPort = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('systemLogDir', node)
        if value is not None and 'systemLogDir' not in already_processed:
            already_processed.add('systemLogDir')
            self.systemLogDir = value
        value = find_attr_value_('tlsEnabled', node)
        if value is not None and 'tlsEnabled' not in already_processed:
            already_processed.add('tlsEnabled')
            if value in ('true', '1'):
                self.tlsEnabled = True
            elif value in ('false', '0'):
                self.tlsEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NodeConfig, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            obj_ = NodeAddress.factory()
            obj_.build(child_)
            self.address.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'earlierInfaHomeConfig':
            obj_ = EarlierInfaHomeConfig.factory()
            obj_.build(child_)
            self.earlierInfaHomeConfig.append(obj_)
            obj_.original_tagname_ = 'earlierInfaHomeConfig'
        elif nodeName_ == 'httpsInfo':
            obj_ = HttpsInfo.factory()
            obj_.build(child_)
            self.httpsInfo.append(obj_)
            obj_.original_tagname_ = 'httpsInfo'
        elif nodeName_ == 'portals':
            obj_ = portalsType.factory()
            obj_.build(child_)
            self.portals.append(obj_)
            obj_.original_tagname_ = 'portals'
        elif nodeName_ == 'predefinedResources':
            obj_ = predefinedResourcesType.factory()
            obj_.build(child_)
            self.predefinedResources.append(obj_)
            obj_.original_tagname_ = 'predefinedResources'
        elif nodeName_ == 'resources':
            obj_ = resourcesType.factory()
            obj_.build(child_)
            self.resources.append(obj_)
            obj_.original_tagname_ = 'resources'
        elif nodeName_ == 'securityConfig':
            obj_ = SecurityConfig.factory()
            obj_.build(child_)
            self.securityConfig.append(obj_)
            obj_.original_tagname_ = 'securityConfig'
        super(NodeConfig, self).buildChildren(child_, node, nodeName_, True)
# end class NodeConfig


class LinkedDomainStorage(ISPObject):
    subclass = None
    superclass = ISPObject
    def __init__(self, id=None, idref=None, iid=None, annotations=None, name=None, linkedDomains=None):
        self.original_tagname_ = None
        super(LinkedDomainStorage, self).__init__(id, idref, iid, annotations, )
        self.name = _cast(None, name)
        if linkedDomains is None:
            self.linkedDomains = []
        else:
            self.linkedDomains = linkedDomains
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedDomainStorage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedDomainStorage.subclass:
            return LinkedDomainStorage.subclass(*args_, **kwargs_)
        else:
            return LinkedDomainStorage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linkedDomains(self): return self.linkedDomains
    def set_linkedDomains(self, linkedDomains): self.linkedDomains = linkedDomains
    def add_linkedDomains(self, value): self.linkedDomains.append(value)
    def insert_linkedDomains_at(self, index, value): self.linkedDomains.insert(index, value)
    def replace_linkedDomains_at(self, index, value): self.linkedDomains[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.linkedDomains or
            super(LinkedDomainStorage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='LinkedDomainStorage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinkedDomainStorage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedDomainStorage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='LinkedDomainStorage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='LinkedDomainStorage'):
        super(LinkedDomainStorage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedDomainStorage')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='LinkedDomainStorage', fromsubclass_=False, pretty_print=True):
        super(LinkedDomainStorage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for linkedDomains_ in self.linkedDomains:
            linkedDomains_.export(outfile, level, namespace_, name_='linkedDomains', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(LinkedDomainStorage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'linkedDomains':
            obj_ = linkedDomainsType.factory()
            obj_.build(child_)
            self.linkedDomains.append(obj_)
            obj_.original_tagname_ = 'linkedDomains'
        super(LinkedDomainStorage, self).buildChildren(child_, node, nodeName_, True)
# end class LinkedDomainStorage


class WorkerNodeConfig(NodeConfig):
    subclass = None
    superclass = NodeConfig
    def __init__(self, id=None, idref=None, iid=None, annotations=None, adminconsolePort=None, adminconsoleShutdownPort=None, domainName=None, logServiceDir=None, nodeName=None, options=None, resetHostPort=None, systemLogDir=None, tlsEnabled=None, address=None, earlierInfaHomeConfig=None, httpsInfo=None, portals=None, predefinedResources=None, resources=None, securityConfig=None, encryptedPassword=None, securityDomain=None, username=None):
        self.original_tagname_ = None
        super(WorkerNodeConfig, self).__init__(id, idref, iid, annotations, adminconsolePort, adminconsoleShutdownPort, domainName, logServiceDir, nodeName, options, resetHostPort, systemLogDir, tlsEnabled, address, earlierInfaHomeConfig, httpsInfo, portals, predefinedResources, resources, securityConfig, )
        self.encryptedPassword = _cast(None, encryptedPassword)
        self.securityDomain = _cast(None, securityDomain)
        self.username = _cast(None, username)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WorkerNodeConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WorkerNodeConfig.subclass:
            return WorkerNodeConfig.subclass(*args_, **kwargs_)
        else:
            return WorkerNodeConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_encryptedPassword(self): return self.encryptedPassword
    def set_encryptedPassword(self, encryptedPassword): self.encryptedPassword = encryptedPassword
    def get_securityDomain(self): return self.securityDomain
    def set_securityDomain(self, securityDomain): self.securityDomain = securityDomain
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def hasContent_(self):
        if (
            super(WorkerNodeConfig, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='WorkerNodeConfig', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WorkerNodeConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WorkerNodeConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='WorkerNodeConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='WorkerNodeConfig'):
        super(WorkerNodeConfig, self).exportAttributes(outfile, level, already_processed, namespace_, name_='WorkerNodeConfig')
        if self.encryptedPassword is not None and 'encryptedPassword' not in already_processed:
            already_processed.add('encryptedPassword')
            outfile.write(' encryptedPassword=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.encryptedPassword), input_name='encryptedPassword')), ))
        if self.securityDomain is not None and 'securityDomain' not in already_processed:
            already_processed.add('securityDomain')
            outfile.write(' securityDomain=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.securityDomain), input_name='securityDomain')), ))
        if self.username is not None and 'username' not in already_processed:
            already_processed.add('username')
            outfile.write(' username=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.username), input_name='username')), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='WorkerNodeConfig', fromsubclass_=False, pretty_print=True):
        super(WorkerNodeConfig, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('encryptedPassword', node)
        if value is not None and 'encryptedPassword' not in already_processed:
            already_processed.add('encryptedPassword')
            self.encryptedPassword = value
        value = find_attr_value_('securityDomain', node)
        if value is not None and 'securityDomain' not in already_processed:
            already_processed.add('securityDomain')
            self.securityDomain = value
        value = find_attr_value_('username', node)
        if value is not None and 'username' not in already_processed:
            already_processed.add('username')
            self.username = value
        super(WorkerNodeConfig, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WorkerNodeConfig, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WorkerNodeConfig


class GatewayNodeConfig(NodeConfig):
    """Model Change Log 2.5.1 nupaman 28/12/2011 Added new property :
    'configSettings'"""
    subclass = None
    superclass = NodeConfig
    def __init__(self, id=None, idref=None, iid=None, annotations=None, adminconsolePort=None, adminconsoleShutdownPort=None, domainName=None, logServiceDir=None, nodeName=None, options=None, resetHostPort=None, systemLogDir=None, tlsEnabled=None, address=None, earlierInfaHomeConfig=None, httpsInfo=None, portals=None, predefinedResources=None, resources=None, securityConfig=None, dbConnectivity=None, configSettings=None):
        self.original_tagname_ = None
        super(GatewayNodeConfig, self).__init__(id, idref, iid, annotations, adminconsolePort, adminconsoleShutdownPort, domainName, logServiceDir, nodeName, options, resetHostPort, systemLogDir, tlsEnabled, address, earlierInfaHomeConfig, httpsInfo, portals, predefinedResources, resources, securityConfig, )
        self.dbConnectivity = _cast(None, dbConnectivity)
        if configSettings is None:
            self.configSettings = []
        else:
            self.configSettings = configSettings
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GatewayNodeConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GatewayNodeConfig.subclass:
            return GatewayNodeConfig.subclass(*args_, **kwargs_)
        else:
            return GatewayNodeConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configSettings(self): return self.configSettings
    def set_configSettings(self, configSettings): self.configSettings = configSettings
    def add_configSettings(self, value): self.configSettings.append(value)
    def insert_configSettings_at(self, index, value): self.configSettings.insert(index, value)
    def replace_configSettings_at(self, index, value): self.configSettings[index] = value
    def get_dbConnectivity(self): return self.dbConnectivity
    def set_dbConnectivity(self, dbConnectivity): self.dbConnectivity = dbConnectivity
    def hasContent_(self):
        if (
            self.configSettings or
            super(GatewayNodeConfig, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='domainservice:', name_='GatewayNodeConfig', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GatewayNodeConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayNodeConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='domainservice:', name_='GatewayNodeConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='domainservice:', name_='GatewayNodeConfig'):
        super(GatewayNodeConfig, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayNodeConfig')
        if self.dbConnectivity is not None and 'dbConnectivity' not in already_processed:
            already_processed.add('dbConnectivity')
            outfile.write(' dbConnectivity=%s' % (quote_attrib(self.dbConnectivity), ))
    def exportChildren(self, outfile, level, namespace_='domainservice:', name_='GatewayNodeConfig', fromsubclass_=False, pretty_print=True):
        super(GatewayNodeConfig, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for configSettings_ in self.configSettings:
            configSettings_.export(outfile, level, namespace_, name_='configSettings', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dbConnectivity', node)
        if value is not None and 'dbConnectivity' not in already_processed:
            already_processed.add('dbConnectivity')
            self.dbConnectivity = value
        super(GatewayNodeConfig, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configSettings':
            obj_ = configSettingsType.factory()
            obj_.build(child_)
            self.configSettings.append(obj_)
            obj_.original_tagname_ = 'configSettings'
        super(GatewayNodeConfig, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayNodeConfig


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DBConnectivity'
        rootClass = DBConnectivity
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DBConnectivity'
        rootClass = DBConnectivity
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DBConnectivity'
        rootClass = DBConnectivity
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:domainservice="http://com.informatica.isp.metadata.domainservice/2"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DBConnectivity'
        rootClass = DBConnectivity
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from domainservice import *\n\n')
        sys.stdout.write('import domainservice as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ApplicationService",
    "Command",
    "ComputeNodeConfiguration",
    "CoreService",
    "CppProcess",
    "DBConnectivity",
    "DomainNode",
    "DomainObj",
    "DomainObjectLocate",
    "DomainServiceConfig",
    "EarlierInfaHomeConfig",
    "EarlierVersionDomainObjRefs",
    "ExecutableProcess",
    "Folder",
    "GatewayNodeConfig",
    "Grid",
    "GroupRef",
    "HttpsInfo",
    "IBlob",
    "IBlobs",
    "IGenericAnnotations",
    "IMX",
    "ISPBoolean",
    "ISPInteger",
    "ISPLong",
    "ISPNamedObject",
    "ISPObject",
    "ISPString",
    "IdObj",
    "InstalledNodeResource",
    "JSFProcess",
    "LinkedDomain",
    "LinkedDomainStorage",
    "Node",
    "NodeAddress",
    "NodeCapability",
    "NodeConfig",
    "NodeRef",
    "NodeResource",
    "NodeSamlConfig",
    "Option",
    "OptionGroup",
    "Process",
    "ProcessRuntime",
    "RemoteNode",
    "ResourceString",
    "ResourceStringWithValue",
    "RoleTypeContainer",
    "SecurityConfig",
    "SensitiveOption",
    "Service",
    "ServiceProcessStartupState",
    "ServiceRef",
    "ServiceRuntime",
    "ServiceStartupState",
    "StoredStartupState",
    "TimeOfDay",
    "UserRef",
    "WebAppProcess",
    "WorkerNodeConfig",
    "annotations",
    "capabilitiesType",
    "computeNodeConfigurationsType",
    "configSettingsType",
    "crc",
    "defaultComputeNodeOptionsType",
    "domainOptionsType",
    "envVariablesType",
    "folderObjectsType",
    "gatewaysType",
    "internalProcessOptionsType",
    "internalServiceOptionsType",
    "linkedDomainsType",
    "nodeOptionsType",
    "optionsType",
    "optionsType1",
    "optionsType3",
    "optionsType4",
    "portalsType",
    "predefineResourcesType",
    "predefinedResourcesType",
    "processOptionsType",
    "processStatesType",
    "proxies",
    "proxy",
    "resourceType",
    "resourcesType",
    "resourcesType2",
    "rolesType",
    "serviceOptionsType",
    "serviceProcessesType",
    "serviceRefsType",
    "serviceStatesType"
]
